\hypertarget{namespaceutility_1_1templates}{}\doxysection{utility\+::templates Namespace Reference}
\label{namespaceutility_1_1templates}\index{utility::templates@{utility::templates}}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceutility_1_1templates_a83c52674a4702c061856535ee9e13d3a}\label{namespaceutility_1_1templates_a83c52674a4702c061856535ee9e13d3a}} 
{\footnotesize template$<$typename T , typename Tuple $>$ }\\using {\bfseries tuple\+\_\+contains\+\_\+type} = typename has\+\_\+type$<$ T, Tuple $>$\+::type
\item 
\mbox{\Hypertarget{namespaceutility_1_1templates_ad0f5efc33d80a237ba4546ace6f063bc}\label{namespaceutility_1_1templates_ad0f5efc33d80a237ba4546ace6f063bc}} 
{\footnotesize template$<$template$<$ class... $>$ class Trait, class... Args$>$ }\\using {\bfseries is\+\_\+detected} = typename detail\+::is\+\_\+detected$<$ Trait, void, Args... $>$\+::type
\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceutility_1_1templates_a31b0b746f74234eb8f5d59cfda270a68}\label{namespaceutility_1_1templates_a31b0b746f74234eb8f5d59cfda270a68}} 
enum {\bfseries type\+\_\+qualifier\+\_\+value} \+: uint8\+\_\+t \{ {\bfseries C\+O\+N\+S\+T\+\_\+\+M\+OD} = 1 $<$$<$ 0, 
{\bfseries A\+T\+O\+M\+IC} = 1 $<$$<$ 1, 
{\bfseries V\+A\+L\+UE} = 1 $<$$<$ 2, 
{\bfseries R\+E\+F\+E\+R\+E\+N\+CE} = 1 $<$$<$ 3
 \}
\item 
\mbox{\Hypertarget{namespaceutility_1_1templates_abdba7bc323a28a9f9ec90c8717c183a7}\label{namespaceutility_1_1templates_abdba7bc323a28a9f9ec90c8717c183a7}} 
enum {\bfseries type\+\_\+qualifier} \+: uint8\+\_\+t \{ \newline
{\bfseries I\+S\+\_\+\+P\+O\+I\+N\+T\+ER} = !(uint8\+\_\+t)type\+\_\+qualifier\+\_\+value\+::V\+A\+L\+UE $\vert$ (uint8\+\_\+t)type\+\_\+qualifier\+\_\+value\+::R\+E\+F\+E\+R\+E\+N\+CE, 
{\bfseries I\+S\+\_\+\+V\+A\+L\+U\+E\+\_\+\+R\+E\+F\+E\+R\+E\+N\+CE} = (uint8\+\_\+t)type\+\_\+qualifier\+\_\+value\+::V\+A\+L\+UE $\vert$ (uint8\+\_\+t)type\+\_\+qualifier\+\_\+value\+::R\+E\+F\+E\+R\+E\+N\+CE, 
{\bfseries I\+S\+\_\+\+V\+A\+L\+UE} = (uint8\+\_\+t)type\+\_\+qualifier\+\_\+value\+::V\+A\+L\+UE $\vert$ !(uint8\+\_\+t)type\+\_\+qualifier\+\_\+value\+::R\+E\+F\+E\+R\+E\+N\+CE, 
{\bfseries I\+S\+\_\+\+C\+O\+N\+S\+T\+\_\+\+P\+O\+I\+N\+T\+ER}, 
\newline
{\bfseries I\+S\+\_\+\+C\+O\+N\+S\+T\+\_\+\+V\+A\+L\+U\+E\+\_\+\+R\+E\+F\+E\+R\+E\+N\+CE}, 
{\bfseries I\+S\+\_\+\+C\+O\+N\+S\+T\+\_\+\+V\+A\+L\+UE}
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceutility_1_1templates_ab780ea0d511b27030ea6077b9bde662f}\label{namespaceutility_1_1templates_ab780ea0d511b27030ea6077b9bde662f}} 
{\footnotesize template$<$size\+\_\+t first, size\+\_\+t... remainder$>$ }\\static constexpr size\+\_\+t {\bfseries max} () noexcept
\item 
\mbox{\Hypertarget{namespaceutility_1_1templates_a844d8c38ce2f098defb054c95b232abf}\label{namespaceutility_1_1templates_a844d8c38ce2f098defb054c95b232abf}} 
{\footnotesize template$<$size\+\_\+t first, size\+\_\+t... remainder$>$ }\\static constexpr size\+\_\+t {\bfseries min} () noexcept
\item 
\mbox{\Hypertarget{namespaceutility_1_1templates_ac129cfafed7877d02d9c80697306f2dc}\label{namespaceutility_1_1templates_ac129cfafed7877d02d9c80697306f2dc}} 
{\footnotesize template$<$class... Ts$>$ }\\{\bfseries overloaded} (Ts...) -\/$>$ overloaded$<$ Ts... $>$
\item 
\mbox{\Hypertarget{namespaceutility_1_1templates_ace19ae2ecb8c1788e2ec76ea592d6e0b}\label{namespaceutility_1_1templates_ace19ae2ecb8c1788e2ec76ea592d6e0b}} 
{\footnotesize template$<$size\+\_\+t N, class T $>$ }\\constexpr std\+::array$<$ T, N $>$ {\bfseries make\+\_\+array} (const T \&v) noexcept
\item 
\mbox{\Hypertarget{namespaceutility_1_1templates_a02ccd35186f68e60252bdf32c26179e2}\label{namespaceutility_1_1templates_a02ccd35186f68e60252bdf32c26179e2}} 
{\footnotesize template$<$typename Variant\+Type , typename... Funcs$>$ }\\void {\bfseries match} (Variant\+Type \&\&variant, Funcs... funcs)
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceutility_1_1templates_a5aabb70764bfa6dbc7fd86952fc1dd00}\label{namespaceutility_1_1templates_a5aabb70764bfa6dbc7fd86952fc1dd00}} 
{\footnotesize template$<$typename T $>$ }\\constexpr bool {\bfseries always\+\_\+false\+\_\+v} = always\+\_\+false$<$T$>$\+::value
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Class\+: psl\+::evocable Info\+: evocables are similar to common\+::event in that you can invoke a function or method at any time. Principle difference is that with evocables you assign the std\+::function\textquotesingle{}s parameters beforehand when you invoke the function/method, you use the assigned parameters from beforehand. Details\+: Precautions should be taken when sending std\+::ref() and pointers to the evocable as to not Invoke functions/methods after their lifetime has passed. There are 3 duck typed versions\+:
\begin{DoxyItemize}
\item evocable\+: you can only invoke on this variation
\item evocableR\+: the invokes return value is known
\item evocableT\+: mostly for completion and consistency with the Event A\+PI, has very few use cases 
\end{DoxyItemize}