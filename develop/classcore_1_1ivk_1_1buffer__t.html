<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>core::ivk::buffer_t class | Paradigm Engine C++20 Rendering Library & Toolchain</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon-dark.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Paradigm Engine <span class="m-thin">C++20 Rendering Library & Toolchain</span></a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Pages</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="namespacecore.html">core</a>::<wbr/></span><span class="m-breadcrumb"><a href="namespacecore_1_1ivk.html">ivk</a>::<wbr/></span>buffer_t <span class="m-thin">class</span>
        </h1>
        <p>maps a memory region and interfaces with the driver for read/writes</p>
        <nav class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              Reference
              <ul>
                <li><a href="#typeless-methods">Constructors, destructors, conversion operators</a></li>
                <li><a href="#pub-methods">Public functions</a></li>
              </ul>
            </li>
          </ul>
        </nav>
<p>buffers are used to map regions of memory that the driver should know about, either because they will be used to map GPU resources (geometry, textures, etc..), or because they are used for synchronising information between CPU/GPU (compute results). This class will handle most of the needs for synchonising, and how-to upload the data to the relevant locations as well as managing the internals.</p>
        <section id="typeless-methods">
          <h2><a href="#typeless-methods">Constructors, destructors, conversion operators</a></h2>
          <dl class="m-doc">
            <dt>
              <span class="m-doc-wrap-bumper"><a href="#ab360ebf1e780c1db0ea472dc631dd36a" class="m-doc">buffer_t</a>(</span><span class="m-doc-wrap">core::resource::cache_t&amp; cache,
              const <a href="structcore_1_1resource_1_1metadata.html" class="m-doc">core::<wbr />resource::<wbr />metadata</a>&amp; metaData,
              <a href="classpsl_1_1meta_1_1file.html" class="m-doc">psl::<wbr />meta::<wbr />file</a>* metaFile,
              <a href="classcore_1_1resource_1_1handle.html" class="m-doc">core::<wbr />resource::<wbr />handle</a>&lt;<a href="classcore_1_1ivk_1_1context.html" class="m-doc">core::<wbr />ivk::<wbr />context</a>&gt; context,
              <a href="classcore_1_1resource_1_1handle.html" class="m-doc">core::<wbr />resource::<wbr />handle</a>&lt;<a href="classcore_1_1data_1_1buffer__t.html" class="m-doc">core::<wbr />data::<wbr />buffer_t</a>&gt; buffer_data,
              std::optional&lt;<a href="classcore_1_1resource_1_1handle.html" class="m-doc">core::<wbr />resource::<wbr />handle</a>&lt;<a href="classcore_1_1ivk_1_1buffer__t.html" class="m-doc">core::<wbr />ivk::<wbr />buffer_t</a>&gt;&gt; staging_buffer = std::nullopt)</span>
            </dt>
            <dd>constructs a buffer from the given buffer_data, as well as optionally sets a staging resource.</dd>
          </dl>
        </section>
        <section id="pub-methods">
          <h2><a href="#pub-methods">Public functions</a></h2>
          <dl class="m-doc">
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a6e3b4d29ef9aa780c766f4121846042a" class="m-doc">reserve</a>(</span><span class="m-doc-wrap">vk::DeviceSize size) -&gt; std::optional&lt;<a href="classmemory_1_1segment.html" class="m-doc">memory::<wbr />segment</a>&gt;</span>
            </dt>
            <dd>tries to reserve a region of memory of <em>at least</em> the given size in thye buffer.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#ae4aac162b5452ac3ce8f3d95c03e46b6" class="m-doc">reserve</a>(</span><span class="m-doc-wrap">std::vector&lt;vk::DeviceSize&gt; sizes,
              bool optimize = false) -&gt; std::vector&lt;std::pair&lt;<a href="classmemory_1_1segment.html" class="m-doc">memory::<wbr />segment</a>, <a href="classmemory_1_1range__t.html" class="m-doc">memory::<wbr />range_t</a>&gt;&gt;</span>
            </dt>
            <dd>tries to reserve all requested sizes in the <a href="classmemory_1_1region.html" class="m-doc">memory::<wbr />region</a> of this buffer.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a2c6102aabc941d63b4b1cfdd5ea6f8de" class="m-doc">commit</a>(</span><span class="m-doc-wrap">std::vector&lt;<a href="structcore_1_1gfx_1_1commit__instruction.html" class="m-doc">core::<wbr />gfx::<wbr />commit_instruction</a>&gt; instructions) -&gt; bool</span>
            </dt>
            <dd>tries to find the appropriate method to update the buffer with the commit instructions.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a24669810fc59f804a1821d0c386e331c" class="m-doc">deallocate</a>(</span><span class="m-doc-wrap"><a href="classmemory_1_1segment.html" class="m-doc">memory::<wbr />segment</a>&amp; segment) -&gt; bool</span>
            </dt>
            <dd>marks the specific region of memory available again.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a8ace32dbeb43fe545a6971c33d3d6a4d" class="m-doc">copy_from</a>(</span><span class="m-doc-wrap">const <a href="classcore_1_1ivk_1_1buffer__t.html" class="m-doc">buffer_<wbr />t</a>&amp; other,
              const std::vector&lt;vk::BufferCopy&gt;&amp; copyRegions) -&gt; bool</span>
            </dt>
            <dd>allows you to copy from one buffer into another.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a873ee84f97b0417beb31e05d2e1118fb" class="m-doc">is_busy</a>(</span><span class="m-doc-wrap">) const -&gt; bool</span>
            </dt>
            <dd></dd>
            <dt id="a8e8ed29c8127b44f8e8a610582376b4b">
              <span class="m-doc-wrap-bumper">void <a href="#a8e8ed29c8127b44f8e8a610582376b4b" class="m-doc-self">wait_until_ready</a>(</span><span class="m-doc-wrap">uint64_t timeout = UINT64_MAX) const</span>
            </dt>
            <dd>forcibly wait until all operations are done, or the timeout has been reached.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#ae9afa00070261ede13ade00a815251c3" class="m-doc">copy_to_host</a>(</span><span class="m-doc-wrap">bool compressed_copy = true) const -&gt; std::optional&lt;<a href="classcore_1_1resource_1_1handle.html" class="m-doc">resource::<wbr />handle</a>&lt;<a href="classcore_1_1ivk_1_1buffer__t.html" class="m-doc">buffer_<wbr />t</a>&gt;&gt;</span>
            </dt>
            <dd>makes the buffer available on the host.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a59feb39870cbbb869c63cf68cc21ed49" class="m-doc">copy_to_host</a>(</span><span class="m-doc-wrap">const std::vector&lt;vk::BufferCopy&gt;&amp; copyRegions) const -&gt; std::optional&lt;<a href="classcore_1_1resource_1_1handle.html" class="m-doc">resource::<wbr />handle</a>&lt;<a href="classcore_1_1ivk_1_1buffer__t.html" class="m-doc">buffer_<wbr />t</a>&gt;&gt;</span>
            </dt>
            <dd>makes the buffer available on the host.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#af8e31080900492e89667376f99da8793" class="m-doc">gpu_buffer</a>(</span><span class="m-doc-wrap">) const -&gt; const vk::Buffer&amp;</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a914fa25b30a83b5484b00dc25062b37c" class="m-doc">data</a>(</span><span class="m-doc-wrap">) const -&gt; <a href="classcore_1_1resource_1_1handle.html" class="m-doc">core::<wbr />resource::<wbr />handle</a>&lt;<a href="classcore_1_1data_1_1buffer__t.html" class="m-doc">core::<wbr />data::<wbr />buffer_t</a>&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a9b39a76bdce901249ca68eee515da811" class="m-doc">buffer_info</a>(</span><span class="m-doc-wrap">) -&gt; vk::DescriptorBufferInfo&amp;</span>
            </dt>
            <dd></dd>
          </dl>
        </section>
        <section>
          <h2>Function documentation</h2>
          <section class="m-doc-details" id="ab360ebf1e780c1db0ea472dc631dd36a"><div>
            <h3>
              <span class="m-doc-wrap-bumper"> core::<wbr />ivk::<wbr />buffer_t::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ab360ebf1e780c1db0ea472dc631dd36a" class="m-doc-self">buffer_t</a>(</span><span class="m-doc-wrap">core::resource::cache_t&amp; cache,
              const <a href="structcore_1_1resource_1_1metadata.html" class="m-doc">core::<wbr />resource::<wbr />metadata</a>&amp; metaData,
              <a href="classpsl_1_1meta_1_1file.html" class="m-doc">psl::<wbr />meta::<wbr />file</a>* metaFile,
              <a href="classcore_1_1resource_1_1handle.html" class="m-doc">core::<wbr />resource::<wbr />handle</a>&lt;<a href="classcore_1_1ivk_1_1context.html" class="m-doc">core::<wbr />ivk::<wbr />context</a>&gt; context,
              <a href="classcore_1_1resource_1_1handle.html" class="m-doc">core::<wbr />resource::<wbr />handle</a>&lt;<a href="classcore_1_1data_1_1buffer__t.html" class="m-doc">core::<wbr />data::<wbr />buffer_t</a>&gt; buffer_data,
              std::optional&lt;<a href="classcore_1_1resource_1_1handle.html" class="m-doc">core::<wbr />resource::<wbr />handle</a>&lt;<a href="classcore_1_1ivk_1_1buffer__t.html" class="m-doc">core::<wbr />ivk::<wbr />buffer_t</a>&gt;&gt; staging_buffer = std::nullopt)</span></span>
            </h3>
            <p>constructs a buffer from the given buffer_data, as well as optionally sets a staging resource.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">cache</td>
                  <td></td>
                </tr>
                <tr>
                  <td>metaData</td>
                  <td></td>
                </tr>
                <tr>
                  <td>metaFile</td>
                  <td></td>
                </tr>
                <tr>
                  <td>context</td>
                  <td></td>
                </tr>
                <tr>
                  <td>buffer_data&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>the data source to bind to this buffer. (see note for more info)</td>
                </tr>
                <tr>
                  <td>staging_buffer&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>the staging buffer to use in case staging is needed. (see warning for more info)</td>
                </tr>
              </tbody>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>it is recommended to give a staging_buffer unless you know this is a host-only resource. failing to give a staging resource to a device-local region that cannot be accessed by the host will result in performance degradation as it has to keep making temporary staging buffers instead.</p></aside><aside class="m-note m-info"><h4>Note</h4><p>buffer_data dictates the size, and alignment of this buffer resource. In the event that the allignment is incorrect, a suitable warning (and potential override) will be supplied. If the supplied buffer_data is non-virtual (i.e. backed by real memory location), then the resource will be duplicated and accessible for read access through the <a href="classcore_1_1data_1_1buffer__t.html" class="m-doc">core::<wbr />data::<wbr />buffer_t</a> handle directly.</p></aside>
          </div></section>
          <section class="m-doc-details" id="a6e3b4d29ef9aa780c766f4121846042a"><div>
            <h3>
              <span class="m-doc-wrap-bumper">std::optional&lt;<a href="classmemory_1_1segment.html" class="m-doc">memory::<wbr />segment</a>&gt; core::<wbr />ivk::<wbr />buffer_t::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a6e3b4d29ef9aa780c766f4121846042a" class="m-doc-self">reserve</a>(</span><span class="m-doc-wrap">vk::DeviceSize size)</span></span>
            </h3>
            <p>tries to reserve a region of memory of <em>at least</em> the given size in thye buffer.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">size&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>the minimum size to allocate</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classmemory_1_1segment.html" class="m-doc">memory::<wbr />segment</a> on success.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-doc-details" id="ae4aac162b5452ac3ce8f3d95c03e46b6"><div>
            <h3>
              <span class="m-doc-wrap-bumper">std::vector&lt;std::pair&lt;<a href="classmemory_1_1segment.html" class="m-doc">memory::<wbr />segment</a>, <a href="classmemory_1_1range__t.html" class="m-doc">memory::<wbr />range_t</a>&gt;&gt; core::<wbr />ivk::<wbr />buffer_t::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ae4aac162b5452ac3ce8f3d95c03e46b6" class="m-doc-self">reserve</a>(</span><span class="m-doc-wrap">std::vector&lt;vk::DeviceSize&gt; sizes,
              bool optimize = false)</span></span>
            </h3>
            <p>tries to reserve all requested sizes in the <a href="classmemory_1_1region.html" class="m-doc">memory::<wbr />region</a> of this buffer.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">sizes&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>a container with minimum sizes you want to request.</td>
                </tr>
                <tr>
                  <td>optimize&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>signifies if we should we try to collapse multiple memory::segments into one segment if possible, avoiding fragmentation and overhead.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a vector with as many contained elements as the requested sizes container has.</td>
                </tr>
              </tfoot>
            </table>
<p>optmized version of <a href="classcore_1_1ivk_1_1buffer__t.html#a6e3b4d29ef9aa780c766f4121846042a" class="m-doc">reserve()</a> that works on a batch of data. It will try to satisfy allocating regions of memory of atleast the given accumulative size. Depending on the optimize boolean parameter&#x27;s value this can be in one optimized <a href="classmemory_1_1segment.html" class="m-doc">memory::<wbr />segment</a> (true), or in equal amount of memory::segments as there were elements in the sizes requested container (false). when optimize is true, the returned <a href="classmemory_1_1range__t.html" class="m-doc">memory::<wbr />range_t</a> in the pair signifies the offset from the start of the segment (where the actual memory you requested resides). when optimize is false, range always starts at 0, and ends at the actual allocated size.</p>
          </div></section>
          <section class="m-doc-details" id="a2c6102aabc941d63b4b1cfdd5ea6f8de"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool core::<wbr />ivk::<wbr />buffer_t::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a2c6102aabc941d63b4b1cfdd5ea6f8de" class="m-doc-self">commit</a>(</span><span class="m-doc-wrap">std::vector&lt;<a href="structcore_1_1gfx_1_1commit__instruction.html" class="m-doc">core::<wbr />gfx::<wbr />commit_instruction</a>&gt; instructions)</span></span>
            </h3>
            <p>tries to find the appropriate method to update the buffer with the commit instructions.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">instructions&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>all the instructions you wish to send to the GPU in this batch.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>success if the instruction has been sent.</td>
                </tr>
              </tfoot>
            </table>
<p>this method tries to commit the given instruction into the buffer. depending on the type of buffer how this does that can differ greatly.</p><aside class="m-note m-danger"><h4>Warning</h4><p>if the buffer is device local and no staging buffer is known, it will try to create a staging buffer to facilitate transfers this has a performance overhead.</p></aside><aside class="m-note m-info"><h4>Note</h4><p>this method will try to figure out the best way to send this set of instructions to the GPU, possibly merging instructions together.</p></aside>
          </div></section>
          <section class="m-doc-details" id="a24669810fc59f804a1821d0c386e331c"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool core::<wbr />ivk::<wbr />buffer_t::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a24669810fc59f804a1821d0c386e331c" class="m-doc-self">deallocate</a>(</span><span class="m-doc-wrap"><a href="classmemory_1_1segment.html" class="m-doc">memory::<wbr />segment</a>&amp; segment)</span></span>
            </h3>
            <p>marks the specific region of memory available again.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">segment&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>the region you wish to free up.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>success in case the region was freed. note that in case the buffer was not the owner of the <a href="classmemory_1_1segment.html" class="m-doc">memory::<wbr />segment</a>, false will be returned.</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>no actual memory will be freed. driver resources are created at the start (constructor) and can only be freed completely (destructor). there is no intermediate unless you copy over the resources to a new, smaller buffer. Check <a href="classcore_1_1ivk_1_1buffer__t.html#a8ace32dbeb43fe545a6971c33d3d6a4d" class="m-doc">copy_<wbr />from()</a> for that.</p></aside>
          </div></section>
          <section class="m-doc-details" id="a8ace32dbeb43fe545a6971c33d3d6a4d"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool core::<wbr />ivk::<wbr />buffer_t::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a8ace32dbeb43fe545a6971c33d3d6a4d" class="m-doc-self">copy_from</a>(</span><span class="m-doc-wrap">const <a href="classcore_1_1ivk_1_1buffer__t.html" class="m-doc">buffer_<wbr />t</a>&amp; other,
              const std::vector&lt;vk::BufferCopy&gt;&amp; copyRegions)</span></span>
            </h3>
            <p>allows you to copy from one buffer into another.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">other&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>the buffer to copy from into this instance.</td>
                </tr>
                <tr>
                  <td>copyRegions&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>the batch of copy instructions.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>true in case the instructions were successfully uploaded to the GPU.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-doc-details" id="a873ee84f97b0417beb31e05d2e1118fb"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool core::<wbr />ivk::<wbr />buffer_t::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a873ee84f97b0417beb31e05d2e1118fb" class="m-doc-self">is_busy</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>in case the GPU/driver is busy.</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>could be true for various situations, in case it is busy uploading, or hasn&#x27;t finalized everything yet amongst other.</p></aside>
          </div></section>
          <section class="m-doc-details" id="ae9afa00070261ede13ade00a815251c3"><div>
            <h3>
              <span class="m-doc-wrap-bumper">std::optional&lt;<a href="classcore_1_1resource_1_1handle.html" class="m-doc">resource::<wbr />handle</a>&lt;<a href="classcore_1_1ivk_1_1buffer__t.html" class="m-doc">buffer_<wbr />t</a>&gt;&gt; core::<wbr />ivk::<wbr />buffer_t::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ae9afa00070261ede13ade00a815251c3" class="m-doc-self">copy_to_host</a>(</span><span class="m-doc-wrap">bool compressed_copy = true) const</span></span>
            </h3>
            <p>makes the buffer available on the host.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">compressed_copy&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>when compressed is true, then the buffer will collapse all empty regions and return a buffer that is the size of all actual committed memory.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a handle to a HOST_VISIBLE buffer on success.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-doc-details" id="a59feb39870cbbb869c63cf68cc21ed49"><div>
            <h3>
              <span class="m-doc-wrap-bumper">std::optional&lt;<a href="classcore_1_1resource_1_1handle.html" class="m-doc">resource::<wbr />handle</a>&lt;<a href="classcore_1_1ivk_1_1buffer__t.html" class="m-doc">buffer_<wbr />t</a>&gt;&gt; core::<wbr />ivk::<wbr />buffer_t::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a59feb39870cbbb869c63cf68cc21ed49" class="m-doc-self">copy_to_host</a>(</span><span class="m-doc-wrap">const std::vector&lt;vk::BufferCopy&gt;&amp; copyRegions) const</span></span>
            </h3>
            <p>makes the buffer available on the host.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">copyRegions&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>the regions the new buffer will consist out of. The new buffer will be the size of the accumulate size of the copyRegions (+ alignment rules).</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a handle to a HOST_VISIBLE buffer on success.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-doc-details" id="af8e31080900492e89667376f99da8793"><div>
            <h3>
              <span class="m-doc-wrap-bumper">const vk::Buffer&amp; core::<wbr />ivk::<wbr />buffer_t::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#af8e31080900492e89667376f99da8793" class="m-doc-self">gpu_buffer</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>the vk::Buffer handle.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-doc-details" id="a914fa25b30a83b5484b00dc25062b37c"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="classcore_1_1resource_1_1handle.html" class="m-doc">core::<wbr />resource::<wbr />handle</a>&lt;<a href="classcore_1_1data_1_1buffer__t.html" class="m-doc">core::<wbr />data::<wbr />buffer_t</a>&gt; core::<wbr />ivk::<wbr />buffer_t::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a914fa25b30a83b5484b00dc25062b37c" class="m-doc-self">data</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>the internal buffer data.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-doc-details" id="a9b39a76bdce901249ca68eee515da811"><div>
            <h3>
              <span class="m-doc-wrap-bumper">vk::DescriptorBufferInfo&amp; core::<wbr />ivk::<wbr />buffer_t::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a9b39a76bdce901249ca68eee515da811" class="m-doc-self">buffer_info</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>the vulkan descriptor buffer info.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
        </section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Paradigm Engine C++20 Rendering Library & Toolchain. Created with <a href="https://doxygen.org/">Doxygen</a> 1.8.17 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
