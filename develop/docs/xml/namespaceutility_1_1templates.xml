<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="namespaceutility_1_1templates" kind="namespace" language="C++">
    <compoundname>utility::templates</compoundname>
    <innerclass refid="structutility_1_1templates_1_1all__same" prot="public">utility::templates::all_same</innerclass>
    <innerclass refid="structutility_1_1templates_1_1all__same_3_01_t_01_4" prot="public">utility::templates::all_same&lt; T &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1all__same_3_01_t_00_01_t_00_01args_8_8_8_01_4" prot="public">utility::templates::all_same&lt; T, T, args... &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1always__false" prot="public">utility::templates::always_false</innerclass>
    <innerclass refid="structutility_1_1templates_1_1any" prot="public">utility::templates::any</innerclass>
    <innerclass refid="structutility_1_1templates_1_1conditional__value" prot="public">utility::templates::conditional_value</innerclass>
    <innerclass refid="structutility_1_1templates_1_1func__traits" prot="public">utility::templates::func_traits</innerclass>
    <innerclass refid="structutility_1_1templates_1_1func__traits_3_01const_01std_1_1function_3_01_t_01_4_01_6_01_4" prot="public">utility::templates::func_traits&lt; const std::function&lt; T &gt; &amp; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1func__traits_3_01_ret_07_5_08_07_args_8_8_8_08_4" prot="public">utility::templates::func_traits&lt; Ret(*)(Args...)&gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1func__traits_3_01_ret_07_c_1_1_5_08_07_args_8_8_8_08_01const_01_4" prot="public">utility::templates::func_traits&lt; Ret(C::*)(Args...) const &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1func__traits_3_01_ret_07_c_1_1_5_08_07_args_8_8_8_08_4" prot="public">utility::templates::func_traits&lt; Ret(C::*)(Args...)&gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1func__traits_3_01std_1_1function_3_01_t_01_4_01_6_01_4" prot="public">utility::templates::func_traits&lt; std::function&lt; T &gt; &amp; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1func__traits_3_01std_1_1function_3_01_t_01_4_01_4" prot="public">utility::templates::func_traits&lt; std::function&lt; T &gt; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__key__type" prot="public">utility::templates::get_key_type</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__key__type_3_01std_1_1unordered__map_3_01_t_00_01_a_01_4_01_4" prot="public">utility::templates::get_key_type&lt; std::unordered_map&lt; T, A &gt; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__type__qualifier" prot="public">utility::templates::get_type_qualifier</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__type__qualifier_3_01const_01_t_01_6_01_4" prot="public">utility::templates::get_type_qualifier&lt; const T &amp; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__type__qualifier_3_01_t_01_6_01_4" prot="public">utility::templates::get_type_qualifier&lt; T &amp; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__type__qualifier_3_01_t_01_6_6_01_4" prot="public">utility::templates::get_type_qualifier&lt; T &amp;&amp; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__type__qualifier_3_01_t_01_5_01_4" prot="public">utility::templates::get_type_qualifier&lt; T * &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__type__qualifier_3_01_t_01_5_5_01_4" prot="public">utility::templates::get_type_qualifier&lt; T ** &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__type__qualifier_3_01_t_01_5const_01_4" prot="public">utility::templates::get_type_qualifier&lt; T *const &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__type__qualifier_3_01_t_01const_01_5_01_4" prot="public">utility::templates::get_type_qualifier&lt; T const * &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__type__qualifier_3_01_t_01const_01_5const_01_4" prot="public">utility::templates::get_type_qualifier&lt; T const *const &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__type__qualifier__v" prot="public">utility::templates::get_type_qualifier_v</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__type__qualifier__v_3_01std_1_1tuple_3_01_t_8_8_8_01_4_01_4" prot="public">utility::templates::get_type_qualifier_v&lt; std::tuple&lt; T... &gt; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__value__type" prot="public">utility::templates::get_value_type</innerclass>
    <innerclass refid="structutility_1_1templates_1_1get__value__type_3_01std_1_1unordered__map_3_01_t_00_01_a_01_4_01_4" prot="public">utility::templates::get_value_type&lt; std::unordered_map&lt; T, A &gt; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1has__type" prot="public">utility::templates::has_type</innerclass>
    <innerclass refid="structutility_1_1templates_1_1has__type_3_01_t_00_01std_1_1tuple_3_01_t_00_01_ts_8_8_8_01_4_01_4" prot="public">utility::templates::has_type&lt; T, std::tuple&lt; T, Ts... &gt; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1has__type_3_01_t_00_01std_1_1tuple_3_01_u_00_01_ts_8_8_8_01_4_01_4" prot="public">utility::templates::has_type&lt; T, std::tuple&lt; U, Ts... &gt; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1has__type_3_01_t_00_01std_1_1tuple_3_4_01_4" prot="public">utility::templates::has_type&lt; T, std::tuple&lt;&gt; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1is__associative__container" prot="public">utility::templates::is_associative_container</innerclass>
    <innerclass refid="structutility_1_1templates_1_1is__associative__container_3_01std_1_1unordered__map_3_01_t_00_01_a_01_4_01_4" prot="public">utility::templates::is_associative_container&lt; std::unordered_map&lt; T, A &gt; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1is__callable__n" prot="public">utility::templates::is_callable_n</innerclass>
    <innerclass refid="structutility_1_1templates_1_1is__callable__n_3_01_f_00_01_n_00_01std_1_1index__sequence_3_01_id66b63670e47385aaccc89064b6f9bc7b" prot="public">utility::templates::is_callable_n&lt; F, N, std::index_sequence&lt; Idx... &gt;, std::void_t&lt; decltype(std::declval&lt; F &gt;()((Idx, std::declval&lt; any const &amp;&amp; &gt;())...))&gt; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1is__complex__container" prot="public">utility::templates::is_complex_container</innerclass>
    <innerclass refid="structutility_1_1templates_1_1is__complex__container_3_01std_1_1tuple_3_01_t_00_01_a_8_8_8_01_4_01_4" prot="public">utility::templates::is_complex_container&lt; std::tuple&lt; T, A... &gt; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1is__complex__container_3_01std_1_1unordered__set_3_01_t_00_01_a_01_4_01_4" prot="public">utility::templates::is_complex_container&lt; std::unordered_set&lt; T, A &gt; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1is__container" prot="public">utility::templates::is_container</innerclass>
    <innerclass refid="structutility_1_1templates_1_1is__invocable" prot="public">utility::templates::is_invocable</innerclass>
    <innerclass refid="structutility_1_1templates_1_1is__pair" prot="public">utility::templates::is_pair</innerclass>
    <innerclass refid="structutility_1_1templates_1_1is__pair_3_01std_1_1pair_3_01_t_00_01_a_01_4_01_4" prot="public">utility::templates::is_pair&lt; std::pair&lt; T, A &gt; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1is__trivial__container" prot="public">utility::templates::is_trivial_container</innerclass>
    <innerclass refid="structutility_1_1templates_1_1is__trivial__container_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4" prot="public">utility::templates::is_trivial_container&lt; std::vector&lt; T, A &gt; &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1overloaded" prot="public">utility::templates::overloaded</innerclass>
    <innerclass refid="structutility_1_1templates_1_1proxy__type" prot="public">utility::templates::proxy_type</innerclass>
    <innerclass refid="structutility_1_1templates_1_1remove__all" prot="public">utility::templates::remove_all</innerclass>
    <innerclass refid="structutility_1_1templates_1_1remove__all_3_01_t_01_5_01_4" prot="public">utility::templates::remove_all&lt; T * &gt;</innerclass>
    <innerclass refid="structutility_1_1templates_1_1type__container" prot="public">utility::templates::type_container</innerclass>
    <innernamespace refid="namespaceutility_1_1templates_1_1detail">utility::templates::detail</innernamespace>
    <innernamespace refid="namespaceutility_1_1templates_1_1details">utility::templates::details</innernamespace>
    <innernamespace refid="namespaceutility_1_1templates_1_1match__detail">utility::templates::match_detail</innernamespace>
    <innernamespace refid="namespaceutility_1_1templates_1_1operators">utility::templates::operators</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="namespaceutility_1_1templates_1a31b0b746f74234eb8f5d59cfda270a68" prot="public" static="no" strong="yes">
        <type>uint8_t</type>
        <name>type_qualifier_value</name>
        <enumvalue id="namespaceutility_1_1templates_1a31b0b746f74234eb8f5d59cfda270a68a0fe1f021ff4c6c5c10f5db59c86b4fb5" prot="public">
          <name>CONST_MOD</name>
          <initializer>= 1 &lt;&lt; 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceutility_1_1templates_1a31b0b746f74234eb8f5d59cfda270a68aef668eed93582ab6729f8a7e679d4f4a" prot="public">
          <name>ATOMIC</name>
          <initializer>= 1 &lt;&lt; 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceutility_1_1templates_1a31b0b746f74234eb8f5d59cfda270a68aecc2e9c313faddb07e7da223c1dc5c3f" prot="public">
          <name>VALUE</name>
          <initializer>= 1 &lt;&lt; 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceutility_1_1templates_1a31b0b746f74234eb8f5d59cfda270a68adcd320d017d7f3c317bc8b234287bc9f" prot="public">
          <name>REFERENCE</name>
          <initializer>= 1 &lt;&lt; 3</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/evoke.hpp" line="20" column="1" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/evoke.hpp" bodystart="19" bodyend="25"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceutility_1_1templates_1abdba7bc323a28a9f9ec90c8717c183a7" prot="public" static="no" strong="yes">
        <type>uint8_t</type>
        <name>type_qualifier</name>
        <enumvalue id="namespaceutility_1_1templates_1abdba7bc323a28a9f9ec90c8717c183a7a81bbfafb02f85f4733142fc92aeb88ce" prot="public">
          <name>IS_POINTER</name>
          <initializer>= !(uint8_t)type_qualifier_value::VALUE | (uint8_t)type_qualifier_value::REFERENCE</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceutility_1_1templates_1abdba7bc323a28a9f9ec90c8717c183a7affba951703c5b4bc4b53c4b096fa17c1" prot="public">
          <name>IS_VALUE_REFERENCE</name>
          <initializer>= (uint8_t)type_qualifier_value::VALUE | (uint8_t)type_qualifier_value::REFERENCE</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceutility_1_1templates_1abdba7bc323a28a9f9ec90c8717c183a7aeda8b89394e1455474f29f8eb9315c6b" prot="public">
          <name>IS_VALUE</name>
          <initializer>= (uint8_t)type_qualifier_value::VALUE | !(uint8_t)type_qualifier_value::REFERENCE</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceutility_1_1templates_1abdba7bc323a28a9f9ec90c8717c183a7a813640f38cdb80054b6b0ba79222f6de" prot="public">
          <name>IS_CONST_POINTER</name>
          <initializer>= (uint8_t)type_qualifier_value::CONST_MOD | !(uint8_t)type_qualifier_value::VALUE |
						   (uint8_t)type_qualifier_value::REFERENCE</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceutility_1_1templates_1abdba7bc323a28a9f9ec90c8717c183a7a88329358d5cbd690e653780b355d510a" prot="public">
          <name>IS_CONST_VALUE_REFERENCE</name>
          <initializer>= (uint8_t)type_qualifier_value::CONST_MOD | (uint8_t)type_qualifier_value::VALUE |
								   (uint8_t)type_qualifier_value::REFERENCE</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceutility_1_1templates_1abdba7bc323a28a9f9ec90c8717c183a7a89e7c03fbdd4cb92c0b94a0bdbb73561" prot="public">
          <name>IS_CONST_VALUE</name>
          <initializer>= (uint8_t)type_qualifier_value::CONST_MOD | (uint8_t)type_qualifier_value::VALUE |
						 !(uint8_t)type_qualifier_value::REFERENCE</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/evoke.hpp" line="28" column="1" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/evoke.hpp" bodystart="27" bodyend="39"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespaceutility_1_1templates_1a83c52674a4702c061856535ee9e13d3a" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Tuple</type>
          </param>
        </templateparamlist>
        <type>typename has_type&lt; T, Tuple &gt;::type</type>
        <definition>using utility::templates::tuple_contains_type = typedef typename has_type&lt;T, Tuple&gt;::type</definition>
        <argsstring></argsstring>
        <name>tuple_contains_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" line="98" column="1" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" bodystart="98" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceutility_1_1templates_1ad0f5efc33d80a237ba4546ace6f063bc" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>Trait</declname>
            <defname>Trait</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>typename detail::is_detected&lt; Trait, void, Args... &gt;::type</type>
        <definition>using utility::templates::is_detected = typedef typename detail::is_detected&lt;Trait, void, Args...&gt;::type</definition>
        <argsstring></argsstring>
        <name>is_detected</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" line="121" column="1" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" bodystart="121" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespaceutility_1_1templates_1a5aabb70764bfa6dbc7fd86952fc1dd00" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool utility::templates::always_false_v</definition>
        <argsstring></argsstring>
        <name>always_false_v</name>
        <initializer>= always_false&lt;T&gt;::value</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" line="107" column="23" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" bodystart="107" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespaceutility_1_1templates_1ab780ea0d511b27030ea6077b9bde662f" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>size_t</type>
            <declname>first</declname>
            <defname>first</defname>
          </param>
          <param>
            <type>size_t...</type>
            <declname>remainder</declname>
            <defname>remainder</defname>
          </param>
        </templateparamlist>
        <type>constexpr size_t</type>
        <definition>static constexpr size_t utility::templates::max</definition>
        <argsstring>() noexcept</argsstring>
        <name>max</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" line="39" column="25" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" bodystart="39" bodyend="47"/>
      </memberdef>
      <memberdef kind="function" id="namespaceutility_1_1templates_1a844d8c38ce2f098defb054c95b232abf" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>size_t</type>
            <declname>first</declname>
            <defname>first</defname>
          </param>
          <param>
            <type>size_t...</type>
            <declname>remainder</declname>
            <defname>remainder</defname>
          </param>
        </templateparamlist>
        <type>constexpr size_t</type>
        <definition>static constexpr size_t utility::templates::min</definition>
        <argsstring>() noexcept</argsstring>
        <name>min</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" line="50" column="25" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" bodystart="50" bodyend="58"/>
      </memberdef>
      <memberdef kind="function" id="namespaceutility_1_1templates_1ac129cfafed7877d02d9c80697306f2dc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type></type>
        <definition>utility::templates::overloaded</definition>
        <argsstring>(Ts...) -&gt; overloaded&lt; Ts... &gt;</argsstring>
        <name>overloaded</name>
        <param>
          <type>Ts...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" line="66" column="1" declfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" declline="66" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceutility_1_1templates_1ace19ae2ecb8c1788e2ec76ea592d6e0b" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr std::array&lt; T, N &gt;</type>
        <definition>constexpr std::array&lt;T, N&gt; utility::templates::make_array</definition>
        <argsstring>(const T &amp;v) noexcept</argsstring>
        <name>make_array</name>
        <param>
          <type>const T &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" line="69" column="22" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" bodystart="69" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="namespaceutility_1_1templates_1a02ccd35186f68e60252bdf32c26179e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename VariantType</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Funcs</declname>
            <defname>Funcs</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void utility::templates::match</definition>
        <argsstring>(VariantType &amp;&amp;variant, Funcs... funcs)</argsstring>
        <name>match</name>
        <param>
          <type>VariantType &amp;&amp;</type>
          <declname>variant</declname>
        </param>
        <param>
          <type>Funcs...</type>
          <declname>funcs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" line="162" column="6" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/template_utils.hpp" bodystart="162" bodyend="168"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Class: psl::evocable Info: evocables are similar to common::event in that you can invoke a function or method at any time. Principle difference is that with evocables you assign the std::function&apos;s parameters beforehand when you invoke the function/method, you use the assigned parameters from beforehand. Details: Precautions should be taken when sending std::ref() and pointers to the evocable as to not Invoke functions/methods after their lifetime has passed. There are 3 duck typed versions:<itemizedlist>
<listitem><para>evocable: you can only invoke on this variation</para>
</listitem><listitem><para>evocableR: the invokes return value is known</para>
</listitem><listitem><para>evocableT: mostly for completion and consistency with the Event API, has very few use cases </para>
</listitem></itemizedlist>
</para>
    </detaileddescription>
    <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/evoke.hpp" line="18" column="1"/>
  </compounddef>
</doxygen>
