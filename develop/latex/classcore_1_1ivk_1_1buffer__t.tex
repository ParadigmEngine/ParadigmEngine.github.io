\hypertarget{classcore_1_1ivk_1_1buffer__t}{}\doxysection{core\+::ivk\+::buffer\+\_\+t Class Reference}
\label{classcore_1_1ivk_1_1buffer__t}\index{core::ivk::buffer\_t@{core::ivk::buffer\_t}}


maps a memory region and interfaces with the driver for read/writes  




{\ttfamily \#include $<$buffer.\+hpp$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_ab360ebf1e780c1db0ea472dc631dd36a}{buffer\+\_\+t}} (core\+::resource\+::cache\+\_\+t \&cache, const \mbox{\hyperlink{structcore_1_1resource_1_1metadata}{core\+::resource\+::metadata}} \&meta\+Data, \mbox{\hyperlink{classpsl_1_1meta_1_1file}{psl\+::meta\+::file}} $\ast$meta\+File, \mbox{\hyperlink{classcore_1_1resource_1_1handle}{core\+::resource\+::handle}}$<$ \mbox{\hyperlink{classcore_1_1ivk_1_1context}{core\+::ivk\+::context}} $>$ \mbox{\hyperlink{classcore_1_1ivk_1_1context}{context}}, \mbox{\hyperlink{classcore_1_1resource_1_1handle}{core\+::resource\+::handle}}$<$ \mbox{\hyperlink{classcore_1_1data_1_1buffer__t}{core\+::data\+::buffer\+\_\+t}} $>$ buffer\+\_\+data, std\+::optional$<$ \mbox{\hyperlink{classcore_1_1resource_1_1handle}{core\+::resource\+::handle}}$<$ \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t}{core\+::ivk\+::buffer\+\_\+t}} $>$$>$ staging\+\_\+buffer=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em constructs a buffer from the given buffer\+\_\+data, as well as optionally sets a staging resource. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_af445fae2a2318d1631b3a99c3765ab24}\label{classcore_1_1ivk_1_1buffer__t_af445fae2a2318d1631b3a99c3765ab24}} 
{\bfseries buffer\+\_\+t} (const \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t}{buffer\+\_\+t}} \&)=delete
\item 
\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_ad71cfe324f30bffb43dfe8562a342b58}\label{classcore_1_1ivk_1_1buffer__t_ad71cfe324f30bffb43dfe8562a342b58}} 
{\bfseries buffer\+\_\+t} (\mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t}{buffer\+\_\+t}} \&\&)=delete
\item 
\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_af046919cc43639e3650e117e1c11c762}\label{classcore_1_1ivk_1_1buffer__t_af046919cc43639e3650e117e1c11c762}} 
\mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t}{buffer\+\_\+t}} \& {\bfseries operator=} (const \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t}{buffer\+\_\+t}} \&)=delete
\item 
\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_a33b98f59558a6ec95bbabcfb763ceb3b}\label{classcore_1_1ivk_1_1buffer__t_a33b98f59558a6ec95bbabcfb763ceb3b}} 
\mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t}{buffer\+\_\+t}} \& {\bfseries operator=} (\mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t}{buffer\+\_\+t}} \&\&)=delete
\item 
std\+::optional$<$ \mbox{\hyperlink{classmemory_1_1segment}{memory\+::segment}} $>$ \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_a6e3b4d29ef9aa780c766f4121846042a}{reserve}} (vk\+::\+Device\+Size size)
\begin{DoxyCompactList}\small\item\em tries to reserve a region of memory of {\itshape at least} the given size in thye buffer. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_aac1d6a6d30042df9bd9245b70f1fff33}\label{classcore_1_1ivk_1_1buffer__t_aac1d6a6d30042df9bd9245b70f1fff33}} 
size\+\_\+t {\bfseries free\+\_\+size} () const noexcept
\item 
std\+::vector$<$ std\+::pair$<$ \mbox{\hyperlink{classmemory_1_1segment}{memory\+::segment}}, \mbox{\hyperlink{classmemory_1_1range__t}{memory\+::range\+\_\+t}} $>$ $>$ \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_ae4aac162b5452ac3ce8f3d95c03e46b6}{reserve}} (std\+::vector$<$ vk\+::\+Device\+Size $>$ sizes, bool optimize=false)
\begin{DoxyCompactList}\small\item\em tries to reserve all requested sizes in the \mbox{\hyperlink{classmemory_1_1region}{memory\+::region}} of this buffer. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_a2c6102aabc941d63b4b1cfdd5ea6f8de}{commit}} (std\+::vector$<$ \mbox{\hyperlink{structcore_1_1gfx_1_1commit__instruction}{core\+::gfx\+::commit\+\_\+instruction}} $>$ instructions)
\begin{DoxyCompactList}\small\item\em tries to find the appropriate method to update the buffer with the commit instructions. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_a24669810fc59f804a1821d0c386e331c}{deallocate}} (\mbox{\hyperlink{classmemory_1_1segment}{memory\+::segment}} \&segment)
\begin{DoxyCompactList}\small\item\em marks the specific region of memory available again. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_a8ace32dbeb43fe545a6971c33d3d6a4d}{copy\+\_\+from}} (const \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t}{buffer\+\_\+t}} \&other, const std\+::vector$<$ vk\+::\+Buffer\+Copy $>$ \&copy\+Regions)
\begin{DoxyCompactList}\small\item\em allows you to copy from one buffer into another. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_a5b75b9a4450972e3df6e6e0470e4da77}\label{classcore_1_1ivk_1_1buffer__t_a5b75b9a4450972e3df6e6e0470e4da77}} 
bool {\bfseries set} (const void $\ast$\mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_a914fa25b30a83b5484b00dc25062b37c}{data}}, std\+::vector$<$ vk\+::\+Buffer\+Copy $>$ commands)
\item 
bool \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_a873ee84f97b0417beb31e05d2e1118fb}{is\+\_\+busy}} () const
\item 
\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_a8e8ed29c8127b44f8e8a610582376b4b}\label{classcore_1_1ivk_1_1buffer__t_a8e8ed29c8127b44f8e8a610582376b4b}} 
void \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_a8e8ed29c8127b44f8e8a610582376b4b}{wait\+\_\+until\+\_\+ready}} (uint64\+\_\+t timeout=U\+I\+N\+T64\+\_\+\+M\+AX) const
\begin{DoxyCompactList}\small\item\em forcibly wait until all operations are done, or the timeout has been reached. \end{DoxyCompactList}\item 
std\+::optional$<$ \mbox{\hyperlink{classcore_1_1resource_1_1handle}{resource\+::handle}}$<$ \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t}{buffer\+\_\+t}} $>$ $>$ \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_ae9afa00070261ede13ade00a815251c3}{copy\+\_\+to\+\_\+host}} (bool compressed\+\_\+copy=true) const
\begin{DoxyCompactList}\small\item\em makes the buffer available on the host. \end{DoxyCompactList}\item 
std\+::optional$<$ \mbox{\hyperlink{classcore_1_1resource_1_1handle}{resource\+::handle}}$<$ \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t}{buffer\+\_\+t}} $>$ $>$ \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_a59feb39870cbbb869c63cf68cc21ed49}{copy\+\_\+to\+\_\+host}} (const std\+::vector$<$ vk\+::\+Buffer\+Copy $>$ \&copy\+Regions) const
\begin{DoxyCompactList}\small\item\em makes the buffer available on the host. \end{DoxyCompactList}\item 
const vk\+::\+Buffer \& \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_af8e31080900492e89667376f99da8793}{gpu\+\_\+buffer}} () const
\item 
\mbox{\hyperlink{classcore_1_1resource_1_1handle}{core\+::resource\+::handle}}$<$ \mbox{\hyperlink{classcore_1_1data_1_1buffer__t}{core\+::data\+::buffer\+\_\+t}} $>$ \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_a914fa25b30a83b5484b00dc25062b37c}{data}} () const
\item 
vk\+::\+Descriptor\+Buffer\+Info \& \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_a9b39a76bdce901249ca68eee515da811}{buffer\+\_\+info}} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
buffers are used to map regions of memory that the driver should know about, either because they will be used to map G\+PU resources (geometry, textures, etc..), or because they are used for synchronising information between C\+P\+U/\+G\+PU (compute results). This class will handle most of the needs for synchonising, and how-\/to upload the data to the relevant locations as well as managing the internals. 

Definition at line 28 of file buffer.\+hpp.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_ab360ebf1e780c1db0ea472dc631dd36a}\label{classcore_1_1ivk_1_1buffer__t_ab360ebf1e780c1db0ea472dc631dd36a}} 
\index{core::ivk::buffer\_t@{core::ivk::buffer\_t}!buffer\_t@{buffer\_t}}
\index{buffer\_t@{buffer\_t}!core::ivk::buffer\_t@{core::ivk::buffer\_t}}
\doxysubsubsection{\texorpdfstring{buffer\_t()}{buffer\_t()}}
{\footnotesize\ttfamily core\+::ivk\+::buffer\+\_\+t\+::buffer\+\_\+t (\begin{DoxyParamCaption}\item[{core\+::resource\+::cache\+\_\+t \&}]{cache,  }\item[{const \mbox{\hyperlink{structcore_1_1resource_1_1metadata}{core\+::resource\+::metadata}} \&}]{meta\+Data,  }\item[{\mbox{\hyperlink{classpsl_1_1meta_1_1file}{psl\+::meta\+::file}} $\ast$}]{meta\+File,  }\item[{\mbox{\hyperlink{classcore_1_1resource_1_1handle}{core\+::resource\+::handle}}$<$ \mbox{\hyperlink{classcore_1_1ivk_1_1context}{core\+::ivk\+::context}} $>$}]{context,  }\item[{\mbox{\hyperlink{classcore_1_1resource_1_1handle}{core\+::resource\+::handle}}$<$ \mbox{\hyperlink{classcore_1_1data_1_1buffer__t}{core\+::data\+::buffer\+\_\+t}} $>$}]{buffer\+\_\+data,  }\item[{std\+::optional$<$ \mbox{\hyperlink{classcore_1_1resource_1_1handle}{core\+::resource\+::handle}}$<$ \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t}{core\+::ivk\+::buffer\+\_\+t}} $>$$>$}]{staging\+\_\+buffer = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em buffer\+\_\+data} & the data source to bind to this buffer. (see note for more info) \\
\hline
\mbox{\texttt{ in}}  & {\em staging\+\_\+buffer} & the staging buffer to use in case staging is needed. (see warning for more info) \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
it is recommended to give a staging\+\_\+buffer unless you know this is a host-\/only resource. failing to give a staging resource to a device-\/local region that cannot be accessed by the host will result in performance degradation as it has to keep making temporary staging buffers instead. 
\end{DoxyWarning}
\begin{DoxyNote}{Note}
buffer\+\_\+data dictates the size, and alignment of this buffer resource. In the event that the allignment is incorrect, a suitable warning (and potential override) will be supplied. If the supplied buffer\+\_\+data is non-\/virtual (i.\+e. backed by real memory location), then the resource will be duplicated and accessible for read access through the \mbox{\hyperlink{classcore_1_1data_1_1buffer__t}{core\+::data\+::buffer\+\_\+t}} handle directly. 
\end{DoxyNote}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_a6e3b4d29ef9aa780c766f4121846042a}\label{classcore_1_1ivk_1_1buffer__t_a6e3b4d29ef9aa780c766f4121846042a}} 
\index{core::ivk::buffer\_t@{core::ivk::buffer\_t}!reserve@{reserve}}
\index{reserve@{reserve}!core::ivk::buffer\_t@{core::ivk::buffer\_t}}
\doxysubsubsection{\texorpdfstring{reserve()}{reserve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::optional$<$ \mbox{\hyperlink{classmemory_1_1segment}{memory\+::segment}} $>$ buffer\+\_\+t\+::reserve (\begin{DoxyParamCaption}\item[{vk\+::\+Device\+Size}]{size }\end{DoxyParamCaption})}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em size} & the minimum size to allocate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a \mbox{\hyperlink{classmemory_1_1segment}{memory\+::segment}} on success. 
\end{DoxyReturn}


Definition at line 127 of file buffer.\+cpp.

\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_ae4aac162b5452ac3ce8f3d95c03e46b6}\label{classcore_1_1ivk_1_1buffer__t_ae4aac162b5452ac3ce8f3d95c03e46b6}} 
\index{core::ivk::buffer\_t@{core::ivk::buffer\_t}!reserve@{reserve}}
\index{reserve@{reserve}!core::ivk::buffer\_t@{core::ivk::buffer\_t}}
\doxysubsubsection{\texorpdfstring{reserve()}{reserve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::vector$<$std\+::pair$<$\mbox{\hyperlink{classmemory_1_1segment}{memory\+::segment}}, \mbox{\hyperlink{classmemory_1_1range__t}{memory\+::range\+\_\+t}}$>$ $>$ core\+::ivk\+::buffer\+\_\+t\+::reserve (\begin{DoxyParamCaption}\item[{std\+::vector$<$ vk\+::\+Device\+Size $>$}]{sizes,  }\item[{bool}]{optimize = {\ttfamily false} }\end{DoxyParamCaption})}

optmized version of \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_a6e3b4d29ef9aa780c766f4121846042a}{reserve()}} that works on a batch of data. It will try to satisfy allocating regions of memory of atleast the given accumulative size. Depending on the optimize boolean parameter\textquotesingle{}s value this can be in one optimized \mbox{\hyperlink{classmemory_1_1segment}{memory\+::segment}} (true), or in equal amount of memory\+::segments as there were elements in the sizes requested container (false). when optimize is true, the returned \mbox{\hyperlink{classmemory_1_1range__t}{memory\+::range\+\_\+t}} in the pair signifies the offset from the start of the segment (where the actual memory you requested resides). when optimize is false, range always starts at 0, and ends at the actual allocated size. \begin{DoxyReturn}{Returns}
a vector with as many contained elements as the requested sizes container has.
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em sizes} & a container with minimum sizes you want to request.\\
\hline
\mbox{\texttt{ in}}  & {\em optimize} & signifies if we should we try to collapse multiple memory\+::segments into one segment if possible, avoiding fragmentation and overhead. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_a2c6102aabc941d63b4b1cfdd5ea6f8de}\label{classcore_1_1ivk_1_1buffer__t_a2c6102aabc941d63b4b1cfdd5ea6f8de}} 
\index{core::ivk::buffer\_t@{core::ivk::buffer\_t}!commit@{commit}}
\index{commit@{commit}!core::ivk::buffer\_t@{core::ivk::buffer\_t}}
\doxysubsubsection{\texorpdfstring{commit()}{commit()}}
{\footnotesize\ttfamily bool buffer\+\_\+t\+::commit (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{structcore_1_1gfx_1_1commit__instruction}{core\+::gfx\+::commit\+\_\+instruction}} $>$}]{instructions }\end{DoxyParamCaption})}

this method tries to commit the given instruction into the buffer. depending on the type of buffer how this does that can differ greatly. \begin{DoxyWarning}{Warning}
if the buffer is device local and no staging buffer is known, it will try to create a staging buffer to facilitate transfers this has a performance overhead.
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em instructions} & all the instructions you wish to send to the G\+PU in this batch. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
success if the instruction has been sent. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this method will try to figure out the best way to send this set of instructions to the G\+PU, possibly merging instructions together. 
\end{DoxyNote}


Definition at line 184 of file buffer.\+cpp.

\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_a24669810fc59f804a1821d0c386e331c}\label{classcore_1_1ivk_1_1buffer__t_a24669810fc59f804a1821d0c386e331c}} 
\index{core::ivk::buffer\_t@{core::ivk::buffer\_t}!deallocate@{deallocate}}
\index{deallocate@{deallocate}!core::ivk::buffer\_t@{core::ivk::buffer\_t}}
\doxysubsubsection{\texorpdfstring{deallocate()}{deallocate()}}
{\footnotesize\ttfamily bool core\+::ivk\+::buffer\+\_\+t\+::deallocate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classmemory_1_1segment}{memory\+::segment}} \&}]{segment }\end{DoxyParamCaption})}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em segment} & the region you wish to free up. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
success in case the region was freed. note that in case the buffer was not the owner of the \mbox{\hyperlink{classmemory_1_1segment}{memory\+::segment}}, false will be returned. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
no actual memory will be freed. driver resources are created at the start (constructor) and can only be freed completely (destructor). there is no intermediate unless you copy over the resources to a new, smaller buffer. Check \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t_a8ace32dbeb43fe545a6971c33d3d6a4d}{copy\+\_\+from()}} for that. 
\end{DoxyNote}
\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_a8ace32dbeb43fe545a6971c33d3d6a4d}\label{classcore_1_1ivk_1_1buffer__t_a8ace32dbeb43fe545a6971c33d3d6a4d}} 
\index{core::ivk::buffer\_t@{core::ivk::buffer\_t}!copy\_from@{copy\_from}}
\index{copy\_from@{copy\_from}!core::ivk::buffer\_t@{core::ivk::buffer\_t}}
\doxysubsubsection{\texorpdfstring{copy\_from()}{copy\_from()}}
{\footnotesize\ttfamily bool buffer\+\_\+t\+::copy\+\_\+from (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t}{buffer\+\_\+t}} \&}]{other,  }\item[{const std\+::vector$<$ vk\+::\+Buffer\+Copy $>$ \&}]{copy\+Regions }\end{DoxyParamCaption})}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em other} & the buffer to copy from into this instance. \\
\hline
\mbox{\texttt{ in}}  & {\em copy\+Regions} & the batch of copy instructions. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true in case the instructions were successfully uploaded to the G\+PU. 
\end{DoxyReturn}


Definition at line 382 of file buffer.\+cpp.

\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_a873ee84f97b0417beb31e05d2e1118fb}\label{classcore_1_1ivk_1_1buffer__t_a873ee84f97b0417beb31e05d2e1118fb}} 
\index{core::ivk::buffer\_t@{core::ivk::buffer\_t}!is\_busy@{is\_busy}}
\index{is\_busy@{is\_busy}!core::ivk::buffer\_t@{core::ivk::buffer\_t}}
\doxysubsubsection{\texorpdfstring{is\_busy()}{is\_busy()}}
{\footnotesize\ttfamily bool buffer\+\_\+t\+::is\+\_\+busy (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

\begin{DoxyReturn}{Returns}
in case the G\+P\+U/driver is busy. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
could be true for various situations, in case it is busy uploading, or hasn\textquotesingle{}t finalized everything yet amongst other. 
\end{DoxyNote}


Definition at line 542 of file buffer.\+cpp.

\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_ae9afa00070261ede13ade00a815251c3}\label{classcore_1_1ivk_1_1buffer__t_ae9afa00070261ede13ade00a815251c3}} 
\index{core::ivk::buffer\_t@{core::ivk::buffer\_t}!copy\_to\_host@{copy\_to\_host}}
\index{copy\_to\_host@{copy\_to\_host}!core::ivk::buffer\_t@{core::ivk::buffer\_t}}
\doxysubsubsection{\texorpdfstring{copy\_to\_host()}{copy\_to\_host()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::optional$<$\mbox{\hyperlink{classcore_1_1resource_1_1handle}{resource\+::handle}}$<$\mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t}{buffer\+\_\+t}}$>$ $>$ core\+::ivk\+::buffer\+\_\+t\+::copy\+\_\+to\+\_\+host (\begin{DoxyParamCaption}\item[{bool}]{compressed\+\_\+copy = {\ttfamily true} }\end{DoxyParamCaption}) const}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em compressed\+\_\+copy} & when compressed is true, then the buffer will collapse all empty regions and return a buffer that is the size of all actual committed memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a handle to a H\+O\+S\+T\+\_\+\+V\+I\+S\+I\+B\+LE buffer on success. 
\end{DoxyReturn}
\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_a59feb39870cbbb869c63cf68cc21ed49}\label{classcore_1_1ivk_1_1buffer__t_a59feb39870cbbb869c63cf68cc21ed49}} 
\index{core::ivk::buffer\_t@{core::ivk::buffer\_t}!copy\_to\_host@{copy\_to\_host}}
\index{copy\_to\_host@{copy\_to\_host}!core::ivk::buffer\_t@{core::ivk::buffer\_t}}
\doxysubsubsection{\texorpdfstring{copy\_to\_host()}{copy\_to\_host()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::optional$<$\mbox{\hyperlink{classcore_1_1resource_1_1handle}{resource\+::handle}}$<$\mbox{\hyperlink{classcore_1_1ivk_1_1buffer__t}{buffer\+\_\+t}}$>$ $>$ core\+::ivk\+::buffer\+\_\+t\+::copy\+\_\+to\+\_\+host (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ vk\+::\+Buffer\+Copy $>$ \&}]{copy\+Regions }\end{DoxyParamCaption}) const}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em copy\+Regions} & the regions the new buffer will consist out of. The new buffer will be the size of the accumulate size of the copy\+Regions (+ alignment rules). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a handle to a H\+O\+S\+T\+\_\+\+V\+I\+S\+I\+B\+LE buffer on success. 
\end{DoxyReturn}
\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_af8e31080900492e89667376f99da8793}\label{classcore_1_1ivk_1_1buffer__t_af8e31080900492e89667376f99da8793}} 
\index{core::ivk::buffer\_t@{core::ivk::buffer\_t}!gpu\_buffer@{gpu\_buffer}}
\index{gpu\_buffer@{gpu\_buffer}!core::ivk::buffer\_t@{core::ivk::buffer\_t}}
\doxysubsubsection{\texorpdfstring{gpu\_buffer()}{gpu\_buffer()}}
{\footnotesize\ttfamily const vk\+::\+Buffer \& buffer\+\_\+t\+::gpu\+\_\+buffer (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

\begin{DoxyReturn}{Returns}
the vk\+::\+Buffer handle. 
\end{DoxyReturn}


Definition at line 553 of file buffer.\+cpp.

\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_a914fa25b30a83b5484b00dc25062b37c}\label{classcore_1_1ivk_1_1buffer__t_a914fa25b30a83b5484b00dc25062b37c}} 
\index{core::ivk::buffer\_t@{core::ivk::buffer\_t}!data@{data}}
\index{data@{data}!core::ivk::buffer\_t@{core::ivk::buffer\_t}}
\doxysubsubsection{\texorpdfstring{data()}{data()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classcore_1_1resource_1_1handle}{core\+::resource\+::handle}}$<$\mbox{\hyperlink{classcore_1_1data_1_1buffer__t}{core\+::data\+::buffer\+\_\+t}}$>$ core\+::ivk\+::buffer\+\_\+t\+::data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

\begin{DoxyReturn}{Returns}
the internal buffer data. 
\end{DoxyReturn}
\mbox{\Hypertarget{classcore_1_1ivk_1_1buffer__t_a9b39a76bdce901249ca68eee515da811}\label{classcore_1_1ivk_1_1buffer__t_a9b39a76bdce901249ca68eee515da811}} 
\index{core::ivk::buffer\_t@{core::ivk::buffer\_t}!buffer\_info@{buffer\_info}}
\index{buffer\_info@{buffer\_info}!core::ivk::buffer\_t@{core::ivk::buffer\_t}}
\doxysubsubsection{\texorpdfstring{buffer\_info()}{buffer\_info()}}
{\footnotesize\ttfamily vk\+::\+Descriptor\+Buffer\+Info \& buffer\+\_\+t\+::buffer\+\_\+info (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
the vulkan descriptor buffer info. 
\end{DoxyReturn}


Definition at line 555 of file buffer.\+cpp.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.\+hpp\item 
/home/runner/work/paradigm/paradigm/core/src/vk/buffer.\+cpp\end{DoxyCompactItemize}
