<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="classcore_1_1ivk_1_1buffer__t" kind="class" language="C++" prot="public">
    <compoundname>core::ivk::buffer_t</compoundname>
    <includes refid="core_2inc_2vk_2buffer_8hpp" local="no">buffer.hpp</includes>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classcore_1_1ivk_1_1buffer__t_1a4b3f8f8215ec2bd5a0f32f5d2740060a" prot="private" static="no" mutable="no">
        <type><ref refid="classcore_1_1resource_1_1handle" kindref="compound">core::resource::handle</ref>&lt; <ref refid="classcore_1_1ivk_1_1context" kindref="compound">core::ivk::context</ref> &gt;</type>
        <definition>core::resource::handle&lt;core::ivk::context&gt; core::ivk::buffer_t::m_Context</definition>
        <argsstring></argsstring>
        <name>m_Context</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="147" column="24" bodyfile="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" bodystart="147" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcore_1_1ivk_1_1buffer__t_1aa91832e10f91b5e3db7327149ea898b6" prot="private" static="no" mutable="no">
        <type>vk::DescriptorBufferInfo</type>
        <definition>vk::DescriptorBufferInfo core::ivk::buffer_t::m_Descriptor</definition>
        <argsstring></argsstring>
        <name>m_Descriptor</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="148" column="26" bodyfile="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" bodystart="148" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcore_1_1ivk_1_1buffer__t_1a1c26aee8f1146d9afd0183274a08de08" prot="private" static="no" mutable="no">
        <type>vk::Buffer</type>
        <definition>vk::Buffer core::ivk::buffer_t::m_Buffer</definition>
        <argsstring></argsstring>
        <name>m_Buffer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="150" column="12" bodyfile="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" bodystart="150" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcore_1_1ivk_1_1buffer__t_1ad561141f8bb7e16e474083a1cac493ac" prot="private" static="no" mutable="no">
        <type>vk::Buffer</type>
        <definition>vk::Buffer core::ivk::buffer_t::m_DoubleBuffer</definition>
        <argsstring></argsstring>
        <name>m_DoubleBuffer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="151" column="12" bodyfile="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" bodystart="151" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcore_1_1ivk_1_1buffer__t_1a8946d4c0746a2a59295708792adb0ce7" prot="private" static="no" mutable="no">
        <type>vk::DeviceMemory</type>
        <definition>vk::DeviceMemory core::ivk::buffer_t::m_Memory</definition>
        <argsstring></argsstring>
        <name>m_Memory</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="152" column="18" bodyfile="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" bodystart="152" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcore_1_1ivk_1_1buffer__t_1a2c2815e237f3d6c295399ac1375c01cf" prot="private" static="no" mutable="no">
        <type>vk::Fence</type>
        <definition>vk::Fence core::ivk::buffer_t::m_BufferCompleted</definition>
        <argsstring></argsstring>
        <name>m_BufferCompleted</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="153" column="11" bodyfile="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" bodystart="153" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcore_1_1ivk_1_1buffer__t_1ac2b93efb6131a90891805621c6dc16ab" prot="private" static="no" mutable="no">
        <type>vk::CommandBuffer</type>
        <definition>vk::CommandBuffer core::ivk::buffer_t::m_CommandBuffer</definition>
        <argsstring></argsstring>
        <name>m_CommandBuffer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="154" column="19" bodyfile="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" bodystart="154" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcore_1_1ivk_1_1buffer__t_1a1d086007198baf1f4d1442568ee1000e" prot="private" static="no" mutable="no">
        <type><ref refid="classcore_1_1resource_1_1handle" kindref="compound">core::resource::handle</ref>&lt; <ref refid="classcore_1_1data_1_1buffer__t" kindref="compound">core::data::buffer_t</ref> &gt;</type>
        <definition>core::resource::handle&lt;core::data::buffer_t&gt; core::ivk::buffer_t::m_BufferDataHandle</definition>
        <argsstring></argsstring>
        <name>m_BufferDataHandle</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="156" column="24" bodyfile="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" bodystart="156" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcore_1_1ivk_1_1buffer__t_1a7f768901337b7c88ccdb63a2bca5c715" prot="private" static="no" mutable="no">
        <type><ref refid="classcore_1_1resource_1_1handle" kindref="compound">core::resource::handle</ref>&lt; <ref refid="classcore_1_1ivk_1_1buffer__t" kindref="compound">core::ivk::buffer_t</ref> &gt;</type>
        <definition>core::resource::handle&lt;core::ivk::buffer_t&gt; core::ivk::buffer_t::m_StagingBuffer</definition>
        <argsstring></argsstring>
        <name>m_StagingBuffer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="157" column="24" bodyfile="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" bodystart="157" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcore_1_1ivk_1_1buffer__t_1a3fa2758f624994befd93e7b67e6de21b" prot="private" static="no" mutable="no">
        <type>core::resource::cache_t &amp;</type>
        <definition>core::resource::cache_t&amp; core::ivk::buffer_t::m_Cache</definition>
        <argsstring></argsstring>
        <name>m_Cache</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="158" column="25" bodyfile="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" bodystart="158" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcore_1_1ivk_1_1buffer__t_1a0e1fd75e33608261207dbe589248d76e" prot="private" static="no" mutable="no">
        <type><ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref></type>
        <definition>psl::UID core::ivk::buffer_t::m_UID</definition>
        <argsstring></argsstring>
        <name>m_UID</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="160" column="10" bodyfile="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" bodystart="160" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1ab360ebf1e780c1db0ea472dc631dd36a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>core::ivk::buffer_t::buffer_t</definition>
        <argsstring>(core::resource::cache_t &amp;cache, const core::resource::metadata &amp;metaData, psl::meta::file *metaFile, core::resource::handle&lt; core::ivk::context &gt; context, core::resource::handle&lt; core::data::buffer_t &gt; buffer_data, std::optional&lt; core::resource::handle&lt; core::ivk::buffer_t &gt;&gt; staging_buffer=std::nullopt)</argsstring>
        <name>buffer_t</name>
        <param>
          <type>core::resource::cache_t &amp;</type>
          <declname>cache</declname>
        </param>
        <param>
          <type>const <ref refid="structcore_1_1resource_1_1metadata" kindref="compound">core::resource::metadata</ref> &amp;</type>
          <declname>metaData</declname>
        </param>
        <param>
          <type><ref refid="classpsl_1_1meta_1_1file" kindref="compound">psl::meta::file</ref> *</type>
          <declname>metaFile</declname>
        </param>
        <param>
          <type><ref refid="classcore_1_1resource_1_1handle" kindref="compound">core::resource::handle</ref>&lt; <ref refid="classcore_1_1ivk_1_1context" kindref="compound">core::ivk::context</ref> &gt;</type>
          <declname>context</declname>
        </param>
        <param>
          <type><ref refid="classcore_1_1resource_1_1handle" kindref="compound">core::resource::handle</ref>&lt; <ref refid="classcore_1_1data_1_1buffer__t" kindref="compound">core::data::buffer_t</ref> &gt;</type>
          <declname>buffer_data</declname>
        </param>
        <param>
          <type>std::optional&lt; <ref refid="classcore_1_1resource_1_1handle" kindref="compound">core::resource::handle</ref>&lt; <ref refid="classcore_1_1ivk_1_1buffer__t" kindref="compound">core::ivk::buffer_t</ref> &gt;&gt;</type>
          <declname>staging_buffer</declname>
          <defval>std::nullopt</defval>
        </param>
        <briefdescription>
<para>constructs a buffer from the given buffer_data, as well as optionally sets a staging resource. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">buffer_data</parametername>
</parameternamelist>
<parameterdescription>
<para>the data source to bind to this buffer. (see note for more info) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">staging_buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>the staging buffer to use in case staging is needed. (see warning for more info) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="warning"><para>it is recommended to give a staging_buffer unless you know this is a host-only resource. failing to give a staging resource to a device-local region that cannot be accessed by the host will result in performance degradation as it has to keep making temporary staging buffers instead. </para>
</simplesect>
<simplesect kind="note"><para>buffer_data dictates the size, and alignment of this buffer resource. In the event that the allignment is incorrect, a suitable warning (and potential override) will be supplied. If the supplied buffer_data is non-virtual (i.e. backed by real memory location), then the resource will be duplicated and accessible for read access through the <ref refid="classcore_1_1data_1_1buffer__t" kindref="compound">core::data::buffer_t</ref> handle directly. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="41" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1ade23e3baa060ca8ab2aaaf10fabf2b29" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>core::ivk::buffer_t::~buffer_t</definition>
        <argsstring>()</argsstring>
        <name>~buffer_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="47" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1af445fae2a2318d1631b3a99c3765ab24" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>core::ivk::buffer_t::buffer_t</definition>
        <argsstring>(const buffer_t &amp;)=delete</argsstring>
        <name>buffer_t</name>
        <param>
          <type>const <ref refid="classcore_1_1ivk_1_1buffer__t" kindref="compound">buffer_t</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="48" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1ad71cfe324f30bffb43dfe8562a342b58" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>core::ivk::buffer_t::buffer_t</definition>
        <argsstring>(buffer_t &amp;&amp;)=delete</argsstring>
        <name>buffer_t</name>
        <param>
          <type><ref refid="classcore_1_1ivk_1_1buffer__t" kindref="compound">buffer_t</ref> &amp;&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="49" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1af046919cc43639e3650e117e1c11c762" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcore_1_1ivk_1_1buffer__t" kindref="compound">buffer_t</ref> &amp;</type>
        <definition>buffer_t&amp; core::ivk::buffer_t::operator=</definition>
        <argsstring>(const buffer_t &amp;)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classcore_1_1ivk_1_1buffer__t" kindref="compound">buffer_t</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="50" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1a33b98f59558a6ec95bbabcfb763ceb3b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcore_1_1ivk_1_1buffer__t" kindref="compound">buffer_t</ref> &amp;</type>
        <definition>buffer_t&amp; core::ivk::buffer_t::operator=</definition>
        <argsstring>(buffer_t &amp;&amp;)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="classcore_1_1ivk_1_1buffer__t" kindref="compound">buffer_t</ref> &amp;&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="51" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1a6e3b4d29ef9aa780c766f4121846042a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="classmemory_1_1segment" kindref="compound">memory::segment</ref> &gt;</type>
        <definition>std::optional&lt; memory::segment &gt; buffer_t::reserve</definition>
        <argsstring>(vk::DeviceSize size)</argsstring>
        <name>reserve</name>
        <param>
          <type>vk::DeviceSize</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>tries to reserve a region of memory of <emphasis>at least</emphasis> the given size in thye buffer. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>the minimum size to allocate </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classmemory_1_1segment" kindref="compound">memory::segment</ref> on success. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="60" column="16" bodyfile="/home/runner/work/paradigm/paradigm/core/src/vk/buffer.cpp" bodystart="127" bodyend="127"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1aac1d6a6d30042df9bd9245b70f1fff33" prot="public" static="no" const="yes" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t core::ivk::buffer_t::free_size</definition>
        <argsstring>() const noexcept</argsstring>
        <name>free_size</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="63" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1ae4aac162b5452ac3ce8f3d95c03e46b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::pair&lt; <ref refid="classmemory_1_1segment" kindref="compound">memory::segment</ref>, <ref refid="classmemory_1_1range__t" kindref="compound">memory::range_t</ref> &gt; &gt;</type>
        <definition>std::vector&lt;std::pair&lt;memory::segment, memory::range_t&gt; &gt; core::ivk::buffer_t::reserve</definition>
        <argsstring>(std::vector&lt; vk::DeviceSize &gt; sizes, bool optimize=false)</argsstring>
        <name>reserve</name>
        <param>
          <type>std::vector&lt; vk::DeviceSize &gt;</type>
          <declname>sizes</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>optimize</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>tries to reserve all requested sizes in the <ref refid="classmemory_1_1region" kindref="compound">memory::region</ref> of this buffer. </para>
        </briefdescription>
        <detaileddescription>
<para>optmized version of <ref refid="classcore_1_1ivk_1_1buffer__t_1a6e3b4d29ef9aa780c766f4121846042a" kindref="member">reserve()</ref> that works on a batch of data. It will try to satisfy allocating regions of memory of atleast the given accumulative size. Depending on the optimize boolean parameter&apos;s value this can be in one optimized <ref refid="classmemory_1_1segment" kindref="compound">memory::segment</ref> (true), or in equal amount of memory::segments as there were elements in the sizes requested container (false). when optimize is true, the returned <ref refid="classmemory_1_1range__t" kindref="compound">memory::range_t</ref> in the pair signifies the offset from the start of the segment (where the actual memory you requested resides). when optimize is false, range always starts at 0, and ends at the actual allocated size. <simplesect kind="return"><para>a vector with as many contained elements as the requested sizes container has.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">sizes</parametername>
</parameternamelist>
<parameterdescription>
<para>a container with minimum sizes you want to request.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">optimize</parametername>
</parameternamelist>
<parameterdescription>
<para>signifies if we should we try to collapse multiple memory::segments into one segment if possible, avoiding fragmentation and overhead. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="76" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1a2c6102aabc941d63b4b1cfdd5ea6f8de" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool buffer_t::commit</definition>
        <argsstring>(std::vector&lt; core::gfx::commit_instruction &gt; instructions)</argsstring>
        <name>commit</name>
        <param>
          <type>std::vector&lt; <ref refid="structcore_1_1gfx_1_1commit__instruction" kindref="compound">core::gfx::commit_instruction</ref> &gt;</type>
          <declname>instructions</declname>
        </param>
        <briefdescription>
<para>tries to find the appropriate method to update the buffer with the commit instructions. </para>
        </briefdescription>
        <detaileddescription>
<para>this method tries to commit the given instruction into the buffer. depending on the type of buffer how this does that can differ greatly. <simplesect kind="warning"><para>if the buffer is device local and no staging buffer is known, it will try to create a staging buffer to facilitate transfers this has a performance overhead.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">instructions</parametername>
</parameternamelist>
<parameterdescription>
<para>all the instructions you wish to send to the GPU in this batch. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>success if the instruction has been sent. </para>
</simplesect>
<simplesect kind="note"><para>this method will try to figure out the best way to send this set of instructions to the GPU, possibly merging instructions together. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="89" column="6" bodyfile="/home/runner/work/paradigm/paradigm/core/src/vk/buffer.cpp" bodystart="184" bodyend="312"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1a24669810fc59f804a1821d0c386e331c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool core::ivk::buffer_t::deallocate</definition>
        <argsstring>(memory::segment &amp;segment)</argsstring>
        <name>deallocate</name>
        <param>
          <type><ref refid="classmemory_1_1segment" kindref="compound">memory::segment</ref> &amp;</type>
          <declname>segment</declname>
        </param>
        <briefdescription>
<para>marks the specific region of memory available again. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">segment</parametername>
</parameternamelist>
<parameterdescription>
<para>the region you wish to free up. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>success in case the region was freed. note that in case the buffer was not the owner of the <ref refid="classmemory_1_1segment" kindref="compound">memory::segment</ref>, false will be returned. </para>
</simplesect>
<simplesect kind="note"><para>no actual memory will be freed. driver resources are created at the start (constructor) and can only be freed completely (destructor). there is no intermediate unless you copy over the resources to a new, smaller buffer. Check <ref refid="classcore_1_1ivk_1_1buffer__t_1a8ace32dbeb43fe545a6971c33d3d6a4d" kindref="member">copy_from()</ref> for that. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="98" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1a8ace32dbeb43fe545a6971c33d3d6a4d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool buffer_t::copy_from</definition>
        <argsstring>(const buffer_t &amp;other, const std::vector&lt; vk::BufferCopy &gt; &amp;copyRegions)</argsstring>
        <name>copy_from</name>
        <param>
          <type>const <ref refid="classcore_1_1ivk_1_1buffer__t" kindref="compound">buffer_t</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <param>
          <type>const std::vector&lt; vk::BufferCopy &gt; &amp;</type>
          <declname>copyRegions</declname>
        </param>
        <briefdescription>
<para>allows you to copy from one buffer into another. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">other</parametername>
</parameternamelist>
<parameterdescription>
<para>the buffer to copy from into this instance. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">copyRegions</parametername>
</parameternamelist>
<parameterdescription>
<para>the batch of copy instructions. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true in case the instructions were successfully uploaded to the GPU. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="108" column="6" bodyfile="/home/runner/work/paradigm/paradigm/core/src/vk/buffer.cpp" bodystart="382" bodyend="479"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1a5b75b9a4450972e3df6e6e0470e4da77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool buffer_t::set</definition>
        <argsstring>(const void *data, std::vector&lt; vk::BufferCopy &gt; commands)</argsstring>
        <name>set</name>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::vector&lt; vk::BufferCopy &gt;</type>
          <declname>commands</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="112" column="6" bodyfile="/home/runner/work/paradigm/paradigm/core/src/vk/buffer.cpp" bodystart="482" bodyend="541"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1a873ee84f97b0417beb31e05d2e1118fb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool buffer_t::is_busy</definition>
        <argsstring>() const</argsstring>
        <name>is_busy</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>in case the GPU/driver is busy. </para>
</simplesect>
<simplesect kind="note"><para>could be true for various situations, in case it is busy uploading, or hasn&apos;t finalized everything yet amongst other. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="117" column="6" bodyfile="/home/runner/work/paradigm/paradigm/core/src/vk/buffer.cpp" bodystart="542" bodyend="542"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1a8e8ed29c8127b44f8e8a610582376b4b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void buffer_t::wait_until_ready</definition>
        <argsstring>(uint64_t timeout=UINT64_MAX) const</argsstring>
        <name>wait_until_ready</name>
        <param>
          <type>uint64_t</type>
          <declname>timeout</declname>
          <defval>UINT64_MAX</defval>
        </param>
        <briefdescription>
<para>forcibly wait until all operations are done, or the timeout has been reached. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="120" column="6" bodyfile="/home/runner/work/paradigm/paradigm/core/src/vk/buffer.cpp" bodystart="544" bodyend="551"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1ae9afa00070261ede13ade00a815251c3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="classcore_1_1resource_1_1handle" kindref="compound">resource::handle</ref>&lt; <ref refid="classcore_1_1ivk_1_1buffer__t" kindref="compound">buffer_t</ref> &gt; &gt;</type>
        <definition>std::optional&lt;resource::handle&lt;buffer_t&gt; &gt; core::ivk::buffer_t::copy_to_host</definition>
        <argsstring>(bool compressed_copy=true) const</argsstring>
        <name>copy_to_host</name>
        <param>
          <type>bool</type>
          <declname>compressed_copy</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>makes the buffer available on the host. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">compressed_copy</parametername>
</parameternamelist>
<parameterdescription>
<para>when compressed is true, then the buffer will collapse all empty regions and return a buffer that is the size of all actual committed memory. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a handle to a HOST_VISIBLE buffer on success. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="126" column="15"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1a59feb39870cbbb869c63cf68cc21ed49" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="classcore_1_1resource_1_1handle" kindref="compound">resource::handle</ref>&lt; <ref refid="classcore_1_1ivk_1_1buffer__t" kindref="compound">buffer_t</ref> &gt; &gt;</type>
        <definition>std::optional&lt;resource::handle&lt;buffer_t&gt; &gt; core::ivk::buffer_t::copy_to_host</definition>
        <argsstring>(const std::vector&lt; vk::BufferCopy &gt; &amp;copyRegions) const</argsstring>
        <name>copy_to_host</name>
        <param>
          <type>const std::vector&lt; vk::BufferCopy &gt; &amp;</type>
          <declname>copyRegions</declname>
        </param>
        <briefdescription>
<para>makes the buffer available on the host. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">copyRegions</parametername>
</parameternamelist>
<parameterdescription>
<para>the regions the new buffer will consist out of. The new buffer will be the size of the accumulate size of the copyRegions (+ alignment rules). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a handle to a HOST_VISIBLE buffer on success. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="134" column="15"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1af8e31080900492e89667376f99da8793" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const vk::Buffer &amp;</type>
        <definition>const vk::Buffer &amp; buffer_t::gpu_buffer</definition>
        <argsstring>() const</argsstring>
        <name>gpu_buffer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>the vk::Buffer handle. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="137" column="18" bodyfile="/home/runner/work/paradigm/paradigm/core/src/vk/buffer.cpp" bodystart="553" bodyend="553"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1a914fa25b30a83b5484b00dc25062b37c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcore_1_1resource_1_1handle" kindref="compound">core::resource::handle</ref>&lt; <ref refid="classcore_1_1data_1_1buffer__t" kindref="compound">core::data::buffer_t</ref> &gt;</type>
        <definition>core::resource::handle&lt;core::data::buffer_t&gt; core::ivk::buffer_t::data</definition>
        <argsstring>() const</argsstring>
        <name>data</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>the internal buffer data. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="140" column="24"/>
      </memberdef>
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1a9b39a76bdce901249ca68eee515da811" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>vk::DescriptorBufferInfo &amp;</type>
        <definition>vk::DescriptorBufferInfo &amp; buffer_t::buffer_info</definition>
        <argsstring>()</argsstring>
        <name>buffer_info</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>the vulkan descriptor buffer info. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="143" column="26" bodyfile="/home/runner/work/paradigm/paradigm/core/src/vk/buffer.cpp" bodystart="555" bodyend="555"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classcore_1_1ivk_1_1buffer__t_1aa2b8f4f5e4c070eda403fe987428b83b" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool buffer_t::map</definition>
        <argsstring>(const void *data, vk::DeviceSize size, vk::DeviceSize offset)</argsstring>
        <name>map</name>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>vk::DeviceSize</type>
          <declname>size</declname>
        </param>
        <param>
          <type>vk::DeviceSize</type>
          <declname>offset</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="146" column="6" bodyfile="/home/runner/work/paradigm/paradigm/core/src/vk/buffer.cpp" bodystart="316" bodyend="372"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>maps a memory region and interfaces with the driver for read/writes </para>
    </briefdescription>
    <detaileddescription>
<para>buffers are used to map regions of memory that the driver should know about, either because they will be used to map GPU resources (geometry, textures, etc..), or because they are used for synchronising information between CPU/GPU (compute results). This class will handle most of the needs for synchonising, and how-to upload the data to the relevant locations as well as managing the internals. </para>
    </detaileddescription>
    <location file="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" line="29" column="1" bodyfile="/home/runner/work/paradigm/paradigm/core/inc/vk/buffer.hpp" bodystart="28" bodyend="161"/>
    <listofallmembers>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a9b39a76bdce901249ca68eee515da811" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>buffer_info</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1ab360ebf1e780c1db0ea472dc631dd36a" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>buffer_t</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1af445fae2a2318d1631b3a99c3765ab24" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>buffer_t</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1ad71cfe324f30bffb43dfe8562a342b58" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>buffer_t</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a2c6102aabc941d63b4b1cfdd5ea6f8de" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>commit</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a8ace32dbeb43fe545a6971c33d3d6a4d" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>copy_from</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1ae9afa00070261ede13ade00a815251c3" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>copy_to_host</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a59feb39870cbbb869c63cf68cc21ed49" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>copy_to_host</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a914fa25b30a83b5484b00dc25062b37c" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>data</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a24669810fc59f804a1821d0c386e331c" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>deallocate</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1aac1d6a6d30042df9bd9245b70f1fff33" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>free_size</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1af8e31080900492e89667376f99da8793" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>gpu_buffer</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a873ee84f97b0417beb31e05d2e1118fb" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>is_busy</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a1c26aee8f1146d9afd0183274a08de08" prot="private" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>m_Buffer</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a2c2815e237f3d6c295399ac1375c01cf" prot="private" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>m_BufferCompleted</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a1d086007198baf1f4d1442568ee1000e" prot="private" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>m_BufferDataHandle</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a3fa2758f624994befd93e7b67e6de21b" prot="private" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>m_Cache</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1ac2b93efb6131a90891805621c6dc16ab" prot="private" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>m_CommandBuffer</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a4b3f8f8215ec2bd5a0f32f5d2740060a" prot="private" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>m_Context</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1aa91832e10f91b5e3db7327149ea898b6" prot="private" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>m_Descriptor</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1ad561141f8bb7e16e474083a1cac493ac" prot="private" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>m_DoubleBuffer</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a8946d4c0746a2a59295708792adb0ce7" prot="private" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>m_Memory</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a7f768901337b7c88ccdb63a2bca5c715" prot="private" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>m_StagingBuffer</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a0e1fd75e33608261207dbe589248d76e" prot="private" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>m_UID</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1aa2b8f4f5e4c070eda403fe987428b83b" prot="private" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>map</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1af046919cc43639e3650e117e1c11c762" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>operator=</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a33b98f59558a6ec95bbabcfb763ceb3b" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>operator=</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a6e3b4d29ef9aa780c766f4121846042a" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>reserve</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1ae4aac162b5452ac3ce8f3d95c03e46b6" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>reserve</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a5b75b9a4450972e3df6e6e0470e4da77" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>set</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1a8e8ed29c8127b44f8e8a610582376b4b" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>wait_until_ready</name></member>
      <member refid="classcore_1_1ivk_1_1buffer__t_1ade23e3baa060ca8ab2aaaf10fabf2b29" prot="public" virt="non-virtual"><scope>core::ivk::buffer_t</scope><name>~buffer_t</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
