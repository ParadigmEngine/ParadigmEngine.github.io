<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="classpsl_1_1meta_1_1library" kind="class" language="C++" prot="public">
    <compoundname>psl::meta::library</compoundname>
    <includes refid="library_8hpp" local="no">library.hpp</includes>
    <innerclass refid="structpsl_1_1meta_1_1library_1_1_u_i_d_data" prot="private">psl::meta::library::UIDData</innerclass>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classpsl_1_1meta_1_1library_1acc93dcae6c6b686c528ba66f568a19fb" prot="private" static="no" mutable="no">
        <type>std::unordered_map&lt; psl::string8_t, std::unordered_set&lt; <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &gt; &gt;</type>
        <definition>std::unordered_map&lt;psl::string8_t, std::unordered_set&lt;psl::UID&gt; &gt; psl::meta::library::m_TagMap</definition>
        <argsstring></argsstring>
        <name>m_TagMap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="340" column="20" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="340" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classpsl_1_1meta_1_1library_1a86e65f23a609f2aa206785652c42e0fc" prot="private" static="no" mutable="no">
        <type>std::unordered_map&lt; <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>, UIDData &gt;</type>
        <definition>std::unordered_map&lt;psl::UID, UIDData&gt; psl::meta::library::m_MetaData</definition>
        <argsstring></argsstring>
        <name>m_MetaData</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="341" column="20" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="341" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classpsl_1_1meta_1_1library_1a20c190043278a642b7110642166ca3dd" prot="private" static="no" mutable="no">
        <type>psl::string8::view</type>
        <definition>psl::string8::view psl::meta::library::m_LibraryFile</definition>
        <argsstring></argsstring>
        <name>m_LibraryFile</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="343" column="20" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="343" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classpsl_1_1meta_1_1library_1a1cdcf1895905ae1724dcb2058f51f8f8" prot="private" static="no" mutable="no">
        <type>psl::string8::view</type>
        <definition>psl::string8::view psl::meta::library::m_LibraryFolder</definition>
        <argsstring></argsstring>
        <name>m_LibraryFolder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="344" column="20" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="344" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classpsl_1_1meta_1_1library_1a110600d02f8d22888763bf1410d04f05" prot="private" static="no" mutable="no">
        <type>psl::string8_t</type>
        <definition>psl::string8_t psl::meta::library::m_LibraryLocation</definition>
        <argsstring></argsstring>
        <name>m_LibraryLocation</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="345" column="16" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="345" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classpsl_1_1meta_1_1library_1a7fb7f9f6a0580c0f2abde29aef3c7369" prot="private" static="no" mutable="no">
        <type>std::vector&lt; psl::string8_t &gt;</type>
        <definition>std::vector&lt;psl::string8_t&gt; psl::meta::library::m_Environment</definition>
        <argsstring></argsstring>
        <name>m_Environment</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="346" column="13" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="346" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a6229350f2c3579b9cdf09a36fd329aee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>library::library</definition>
        <argsstring>(psl::string8::view lib, std::vector&lt; psl::string8_t &gt; environment={})</argsstring>
        <name>library</name>
        <param>
          <type>psl::string8::view</type>
          <declname>lib</declname>
        </param>
        <param>
          <type>std::vector&lt; psl::string8_t &gt;</type>
          <declname>environment</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>location on disk where the library can be found. </para>
        </briefdescription>
        <detaileddescription>
<para>The constructor will try to load the given filepath, and then parse it. It will also create the minimal representation of each <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref> entry in the given file, with its tags, etc..<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">lib</parametername>
</parameternamelist>
<parameterdescription>
<para>The filepath to which file should be loaded. This path can either be absolute or relative. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="100" column="1" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="10" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a963ec33316190d5567f23ae55768e35b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>library::~library</definition>
        <argsstring>()</argsstring>
        <name>~library</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="101" column="1" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="77" bodyend="77"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a88837a8a757c68032c132f122f0ed014" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>psl::meta::library::library</definition>
        <argsstring>(const library &amp;other)=delete</argsstring>
        <name>library</name>
        <param>
          <type>const <ref refid="classpsl_1_1meta_1_1library" kindref="compound">library</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="103" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1adafdc22f21e42c36b5214c4eb1133875" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>psl::meta::library::library</definition>
        <argsstring>(library &amp;&amp;other) noexcept</argsstring>
        <name>library</name>
        <param>
          <type><ref refid="classpsl_1_1meta_1_1library" kindref="compound">library</ref> &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="104" column="1" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="104" bodyend="107"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a84294ded9abf834136f67694f9c87e21" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classpsl_1_1meta_1_1library" kindref="compound">library</ref> &amp;</type>
        <definition>library&amp; psl::meta::library::operator=</definition>
        <argsstring>(const library &amp;other)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classpsl_1_1meta_1_1library" kindref="compound">library</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="108" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a315c8ceb312484a903200c5808fefd95" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type><ref refid="classpsl_1_1meta_1_1library" kindref="compound">library</ref> &amp;</type>
        <definition>library&amp; psl::meta::library::operator=</definition>
        <argsstring>(library &amp;&amp;other) noexcept</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="classpsl_1_1meta_1_1library" kindref="compound">library</ref> &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="109" column="9" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="109" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a811f7c93973a56d03225efd5a2bf5b73" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
            <defval><ref refid="classpsl_1_1meta_1_1file" kindref="compound">file</ref></defval>
          </param>
        </templateparamlist>
        <type>std::pair&lt; const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;, MF &amp; &gt;</type>
        <definition>std::pair&lt;const psl::UID&amp;, MF&amp;&gt; psl::meta::library::create</definition>
        <argsstring>()</argsstring>
        <name>create</name>
        <briefdescription>
<para>creates a new entry with a unique <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> and a given type that is either, or derived of <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="125" column="11" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="125" bodyend="128"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a05acd4ed185b67a3efc1da456462fd79" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
            <defval><ref refid="classpsl_1_1meta_1_1file" kindref="compound">file</ref></defval>
          </param>
        </templateparamlist>
        <type>std::pair&lt; const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;, MF &amp; &gt;</type>
        <definition>std::pair&lt;const psl::UID&amp;, MF&amp;&gt; psl::meta::library::create</definition>
        <argsstring>(psl::string8_t content)</argsstring>
        <name>create</name>
        <param>
          <type>psl::string8_t</type>
          <declname>content</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="131" column="11" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="131" bodyend="134"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1ae0bc675542b66f8452295a4d92378e6f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
            <defval><ref refid="classpsl_1_1meta_1_1file" kindref="compound">file</ref></defval>
          </param>
        </templateparamlist>
        <type>std::pair&lt; const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;, MF &amp; &gt;</type>
        <definition>std::pair&lt;const psl::UID&amp;, MF&amp;&gt; psl::meta::library::add</definition>
        <argsstring>(const psl::UID &amp;uid, std::unique_ptr&lt; MF &gt; metaData)</argsstring>
        <name>add</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <param>
          <type>std::unique_ptr&lt; MF &gt;</type>
          <declname>metaData</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="137" column="11" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="137" bodyend="143"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1ad48f871466b440d7617161f0d10783bc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
            <defval><ref refid="classpsl_1_1meta_1_1file" kindref="compound">file</ref></defval>
          </param>
        </templateparamlist>
        <type>std::pair&lt; const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;, MF &amp; &gt;</type>
        <definition>std::pair&lt;const psl::UID&amp;, MF&amp;&gt; psl::meta::library::create</definition>
        <argsstring>(const psl::UID &amp;uid)</argsstring>
        <name>create</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <briefdescription>
<para>creates a new entry with the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> and a given type that is either, or derived of <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> that should be associated with this entry. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="warning"><para>giving an already present <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> will result in an error log, and you will be given back the instance that is already present. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="149" column="11" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="149" bodyend="162"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a22695a7f4cfa8cfbc8bae75558dccf48" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
            <defval><ref refid="classpsl_1_1meta_1_1file" kindref="compound">file</ref></defval>
          </param>
        </templateparamlist>
        <type>std::pair&lt; const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;, MF &amp; &gt;</type>
        <definition>std::pair&lt;const psl::UID&amp;, MF&amp;&gt; psl::meta::library::create</definition>
        <argsstring>(const psl::UID &amp;uid, psl::string8_t content)</argsstring>
        <name>create</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <param>
          <type>psl::string8_t</type>
          <declname>content</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="165" column="11" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="165" bodyend="179"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a5b7ea7cdb8261d1b5616db6e3bf99690" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool library::serialize</definition>
        <argsstring>(const psl::UID &amp;uid)</argsstring>
        <name>serialize</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <briefdescription>
<para>serializes the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> to disk in case it is present, and an on-disk file. </para>
        </briefdescription>
        <detaileddescription>
<para>When you send a <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> to this method, the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref> will verify that it has an entry with the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>, and that it is linked to an on-disk location. When it satisfies those two requirements, it will then proceed to serialize the file to disk using the current values that are present.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> you wish to serialize. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true when the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> is both present in the library, and it is linked to an on-disk file. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="188" column="6" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="79" bodyend="89"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a3929be0a3af743fa0169f6602304b168" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool library::remove</definition>
        <argsstring>(const psl::UID &amp;uid, bool safe_mode=true)</argsstring>
        <name>remove</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>safe_mode</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>tries to remove the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> from the library. </para>
        </briefdescription>
        <detaileddescription>
<para>Will try to remove the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> from the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref>. On success it will notify all other <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref>&apos;s that it references, that they no longer are being referenced by this instance.</para>
<para><emphasis>safe_mode</emphasis> controls wether you should avoid deleting this instance if others are still referencing this <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> (true), or forcibly delete this instance regardless (false).<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> you wish to remove.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">safe_mode</parametername>
</parameternamelist>
<parameterdescription>
<para>when true (default), will disallow removing as long as this item is being referenced by others. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if the instance was removed or not. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="199" column="6" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="91" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1ab706fec8ce425d3343b872a2a96f4d83" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool library::contains</definition>
        <argsstring>(const psl::UID &amp;uid) const</argsstring>
        <name>contains</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <briefdescription>
<para>searches the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref> if it has an entry that corresponds to the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> to search for. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if found. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="204" column="6" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="127" bodyend="127"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1af33866bae007a7b693ee44ac4856f48f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &gt;</type>
        <definition>std::optional&lt; UID &gt; library::find</definition>
        <argsstring>(psl::string8::view tag) const</argsstring>
        <name>find</name>
        <param>
          <type>psl::string8::view</type>
          <declname>tag</declname>
        </param>
        <briefdescription>
<para>searches for the first <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> that is associated with the given tag. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The tag to look for, it is case-sensetive. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>optionally the first found <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="209" column="15" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="130" bodyend="136"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1ac94429d6420c9a54c6171e453d48e244" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::unordered_set&lt; <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &gt;</type>
        <definition>std::unordered_set&lt; UID &gt; library::find_all</definition>
        <argsstring>(psl::string8::view tag) const</argsstring>
        <name>find_all</name>
        <param>
          <type>psl::string8::view</type>
          <declname>tag</declname>
        </param>
        <briefdescription>
<para>advanced version of <ref refid="classpsl_1_1meta_1_1library_1af33866bae007a7b693ee44ac4856f48f" kindref="member">find()</ref> that finds all instances of the given tag. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The tag to look for, it is case-sensetive. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>an unordered_set of all <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s that have this tag. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="214" column="20" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="137" bodyend="142"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1aa6f273697ac74887e1b30624c3397c6a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const std::vector&lt; psl::string8_t &gt; &amp;</type>
        <definition>const std::vector&lt; psl::string8_t &gt; &amp; library::tags</definition>
        <argsstring>(const psl::UID &amp;uid) const</argsstring>
        <name>tags</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <briefdescription>
<para>get all tags (if any) associated with the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> to get all tags for. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a list of all found tags. </para>
</simplesect>
<simplesect kind="note"><para>even if the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> is not present in the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref>, this method will not fail, it will just find 0 tags. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="221" column="19" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="144" bodyend="151"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1afe942660d07c99617af92ce89e4f807c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool library::has_tag</definition>
        <argsstring>(const psl::UID &amp;uid, psl::string8::view tag) const</argsstring>
        <name>has_tag</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <param>
          <type>psl::string8::view</type>
          <declname>tag</declname>
        </param>
        <briefdescription>
<para>checks if the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> has the specific tag associated to it. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> to check. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tag</parametername>
</parameternamelist>
<parameterdescription>
<para>the associated tag. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if the tag is present on the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>. </para>
</simplesect>
<simplesect kind="note"><para>if the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> is not present in the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref>, then this method always returns false. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="228" column="6" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="153" bodyend="159"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a3f6cfb7e8b3b4e927be163fbcdd68473" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool library::set</definition>
        <argsstring>(const psl::UID &amp;uid, psl::string8::view tag)</argsstring>
        <name>set</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <param>
          <type>psl::string8::view</type>
          <declname>tag</declname>
        </param>
        <briefdescription>
<para>associates the tag with this specific <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> to associate with the tag. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tag</parametername>
</parameternamelist>
<parameterdescription>
<para>the tag to apply to the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>if this was successful or not. It could return false in case the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> is not part of the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref>. </para>
</simplesect>
<simplesect kind="warning"><para>it is possible to set the same tag multiple times on the same <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="235" column="6" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="161" bodyend="169"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1aee7c93cb86c477d300d3f9adc9ef9f3d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool library::set</definition>
        <argsstring>(const psl::UID &amp;uid, std::vector&lt; psl::string8::view &gt; tags)</argsstring>
        <name>set</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <param>
          <type>std::vector&lt; psl::string8::view &gt;</type>
          <declname>tags</declname>
        </param>
        <briefdescription>
<para>advanced version of <ref refid="classpsl_1_1meta_1_1library_1a3f6cfb7e8b3b4e927be163fbcdd68473" kindref="member">set()</ref> that allows a list of tags. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> to associate with the tags. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tags</parametername>
</parameternamelist>
<parameterdescription>
<para>the tags to apply to the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>if this was successful or not. It could return false in case the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> is not part of the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref>. </para>
</simplesect>
<simplesect kind="warning"><para>it is possible to set the same tag multiple times on the same <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="243" column="6" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="170" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a05b36ad8b5bf7df6357c6cf5fd9df00b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::unordered_set&lt; <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &gt;</type>
        <definition>std::unordered_set&lt; UID &gt; library::referencing</definition>
        <argsstring>(const psl::UID &amp;uid) const</argsstring>
        <name>referencing</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <briefdescription>
<para>gets a list of all <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> might be referencing. </para>
        </briefdescription>
        <detaileddescription>
<para>as an example, a <ref refid="classcore_1_1ivk_1_1material__t" kindref="compound">core::ivk::material_t</ref> could be referencing a <ref refid="classcore_1_1ivk_1_1texture__t" kindref="compound">core::ivk::texture_t</ref>, this means that if you call this method using the <ref refid="classcore_1_1ivk_1_1material__t" kindref="compound">core::ivk::material_t</ref>&apos;s <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>, then you will get a list back that atleast contains the <ref refid="classcore_1_1ivk_1_1texture__t" kindref="compound">core::ivk::texture_t</ref> <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> to find all references for. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a list of all <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> is referencing. </para>
</simplesect>
<simplesect kind="note"><para>will return an empty list in case the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> is not present in the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="253" column="20" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="183" bodyend="189"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1ae878be8f2dd25e41318582aae5d5a114" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::unordered_set&lt; <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &gt;</type>
        <definition>std::unordered_set&lt; UID &gt; library::referencedBy</definition>
        <argsstring>(const psl::UID &amp;uid) const</argsstring>
        <name>referencedBy</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <briefdescription>
<para>gets a list of all <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> might be referenced by. </para>
        </briefdescription>
        <detaileddescription>
<para>as an example, a <ref refid="classcore_1_1ivk_1_1texture__t" kindref="compound">core::ivk::texture_t</ref> could be referenced by a <ref refid="classcore_1_1ivk_1_1material__t" kindref="compound">core::ivk::material_t</ref>, this means that if you call this method using the <ref refid="classcore_1_1ivk_1_1texture__t" kindref="compound">core::ivk::texture_t</ref>&apos;s <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>, then you will get a list back that atleast contains the <ref refid="classcore_1_1ivk_1_1material__t" kindref="compound">core::ivk::material_t</ref> <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> for which to find all <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s that might be referencing this <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a list of all <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> is being referenced by. </para>
</simplesect>
<simplesect kind="note"><para>will return an empty list in case the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> is not present in the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="263" column="20" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="190" bodyend="196"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a667f5b9b1544433ad7a8a94403d6afa3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; psl::string8::view &gt;</type>
        <definition>std::optional&lt; psl::string8::view &gt; library::load</definition>
        <argsstring>(const psl::UID &amp;uid)</argsstring>
        <name>load</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <briefdescription>
<para>loads the specific <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s content. </para>
        </briefdescription>
        <detaileddescription>
<para>Loads the specified <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s associated file, <bold>not</bold> <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref>, and returns it (if found). The associated file is the companion file for which the <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref> was generated, for example a shader will have a <ref refid="classcore_1_1meta_1_1shader" kindref="compound">core::meta::shader</ref> file on disk, but also the actual shader file (SPIR-V for Vulkan). This returns the SPIR-V file. The file content will get cached into the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref> to make subsequent <ref refid="classpsl_1_1meta_1_1library_1a667f5b9b1544433ad7a8a94403d6afa3" kindref="member">load()</ref> calls faster.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> to optionally find the content for. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the resulting content in UTF-8 format if found. </para>
</simplesect>
<simplesect kind="warning"><para>this method requires the file to satisfy <ref refid="classpsl_1_1meta_1_1library_1a30001692a65acadf17d3b1315566aebd" kindref="member">is_physical_file()</ref>, otherwise it will silently fail. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="274" column="15" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="217" bodyend="233"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a27e240bd3b3cb65018db5ec58f7178f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool library::unload</definition>
        <argsstring>(const psl::UID &amp;uid)</argsstring>
        <name>unload</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <briefdescription>
<para>purges the specific <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s cachec content. </para>
        </briefdescription>
        <detaileddescription>
<para>Unloads the specified <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s associated file, <bold>not</bold> <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref>, and returns true if it was in the cache and purged. The associated file is the companion file for which the <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref> was generated, for example a shader will have a <ref refid="classcore_1_1meta_1_1shader" kindref="compound">core::meta::shader</ref> file on disk, but also the actual shader file (SPIR-V for Vulkan). This returns the SPIR-V file. You can reload the file into the cache by calling <ref refid="classpsl_1_1meta_1_1library_1a667f5b9b1544433ad7a8a94403d6afa3" kindref="member">load()</ref> with the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> as parameter.<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> to purge from the cache. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if it was found on the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref>, and had cached contents. </para>
</simplesect>
<simplesect kind="warning"><para>this method requires the file to satisfy <ref refid="classpsl_1_1meta_1_1library_1a30001692a65acadf17d3b1315566aebd" kindref="member">is_physical_file()</ref>, otherwise it will silently fail. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="285" column="6" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="235" bodyend="242"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1abf1a7cb98dc581dc2db8e5698458ca7d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
            <defval><ref refid="classpsl_1_1meta_1_1file" kindref="compound">file</ref></defval>
          </param>
        </templateparamlist>
        <type>std::optional&lt; T * &gt;</type>
        <definition>std::optional&lt; T * &gt; psl::meta::library::get</definition>
        <argsstring>(const psl::UID &amp;uid) const</argsstring>
        <name>get</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <briefdescription>
<para>get the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s associated <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref> from the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref> and tries to cast to the templated type. </para>
        </briefdescription>
        <detaileddescription>
<para>Searches the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref> for the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>, and then tries to satisfy the templated type given. If successful it will return the given template type (default <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref>), otherwise it returns an std::nullopt in case the conversion is not possible at runtime, and will give a compile error when the template type does not satisfy the type constraint. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>should satisfy at least being either <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref> or being derived from <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> to find. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref>, or derived class associated with the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>. </para>
</simplesect>
<simplesect kind="warning"><para>this method cannot downcast, it has to satisfy the type perfectly. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="297" column="15" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="349" bodyend="374"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a30001692a65acadf17d3b1315566aebd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool library::is_physical_file</definition>
        <argsstring>(const psl::UID &amp;uid) const</argsstring>
        <name>is_physical_file</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <briefdescription>
<para>checks if the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> is associated with a physical/persistent file, or dynamically created during the runtime. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> to check. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true in case it has a persistent backing (that will survive a reboot). </para>
</simplesect>
<simplesect kind="note"><para>that the physical backing might be out of sync with the current version that is being used by the runtime. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="303" column="6" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="198" bodyend="204"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a992171900bd57998b5721cfdd2c23ab5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; psl::string8_t &gt;</type>
        <definition>std::optional&lt; psl::string8_t &gt; library::get_physical_location</definition>
        <argsstring>(const psl::UID &amp;uid) const</argsstring>
        <name>get_physical_location</name>
        <param>
          <type>const <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> &amp;</type>
          <declname>uid</declname>
        </param>
        <briefdescription>
<para>gets the relative location (to the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref>&apos;s location) of the given <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">uid</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> to check. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the relative location to the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref> if found. </para>
</simplesect>
<simplesect kind="note"><para>silently fails for <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s that are not present in the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="309" column="15" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="205" bodyend="212"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a2b1243cd199b4accef5215d898dc305c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t library::size</definition>
        <argsstring>() const</argsstring>
        <name>size</name>
        <briefdescription>
<para>returns the count of <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s present in the <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>the amount of unique <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s in the current <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="313" column="8" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="214" bodyend="214"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a543ced6f44b1e7286546f6510bb38ce6" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void library::replace_content</definition>
        <argsstring>(psl::UID uid, psl::string8_t content) noexcept</argsstring>
        <name>replace_content</name>
        <param>
          <type><ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref></type>
          <declname>uid</declname>
        </param>
        <param>
          <type>psl::string8_t</type>
          <declname>content</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="315" column="6" bodyfile="/home/runner/work/paradigm/paradigm/psl/src/library.cpp" bodystart="245" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="classpsl_1_1meta_1_1library_1a48d4df208da232b1717166669f56c329" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>const std::vector&lt; psl::string8_t &gt; &amp;</type>
        <definition>const std::vector&lt;psl::string8_t&gt;&amp; psl::meta::library::environment</definition>
        <argsstring>() const noexcept</argsstring>
        <name>environment</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="317" column="19" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="317" bodyend="317"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>container class for <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref>&apos;s </para>
    </briefdescription>
    <detaileddescription>
<para>a <ref refid="classpsl_1_1meta_1_1library" kindref="compound">meta::library</ref> is a collection of <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref> instances. The library will do the basic bookkeeping, allowing you to search and retrieve <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref> instances based on their <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>, or tags and narrow it down depending on the <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref> type as well.</para>
<para>There are also facilities to have <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s reference other <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref>&apos;s, and do bi-directional lookups for these relations. As well as the ability to load the persistent companion file that the <ref refid="classpsl_1_1meta_1_1file" kindref="compound">meta::file</ref> describes (in case the <ref refid="structpsl_1_1_u_i_d" kindref="compound">psl::UID</ref> satisfies <ref refid="classpsl_1_1meta_1_1library_1a30001692a65acadf17d3b1315566aebd" kindref="member">is_physical_file()</ref> ), and to have that companion file cached for faster reloads. </para>
    </detaileddescription>
    <location file="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" line="93" column="1" bodyfile="/home/runner/work/paradigm/paradigm/psl/inc/psl/library.hpp" bodystart="92" bodyend="347"/>
    <listofallmembers>
      <member refid="classpsl_1_1meta_1_1library_1ae0bc675542b66f8452295a4d92378e6f" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>add</name></member>
      <member refid="classpsl_1_1meta_1_1library_1ab706fec8ce425d3343b872a2a96f4d83" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>contains</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a811f7c93973a56d03225efd5a2bf5b73" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>create</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a05acd4ed185b67a3efc1da456462fd79" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>create</name></member>
      <member refid="classpsl_1_1meta_1_1library_1ad48f871466b440d7617161f0d10783bc" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>create</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a22695a7f4cfa8cfbc8bae75558dccf48" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>create</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a48d4df208da232b1717166669f56c329" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>environment</name></member>
      <member refid="classpsl_1_1meta_1_1library_1af33866bae007a7b693ee44ac4856f48f" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>find</name></member>
      <member refid="classpsl_1_1meta_1_1library_1ac94429d6420c9a54c6171e453d48e244" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>find_all</name></member>
      <member refid="classpsl_1_1meta_1_1library_1abf1a7cb98dc581dc2db8e5698458ca7d" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>get</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a992171900bd57998b5721cfdd2c23ab5" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>get_physical_location</name></member>
      <member refid="classpsl_1_1meta_1_1library_1afe942660d07c99617af92ce89e4f807c" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>has_tag</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a30001692a65acadf17d3b1315566aebd" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>is_physical_file</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a6229350f2c3579b9cdf09a36fd329aee" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>library</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a88837a8a757c68032c132f122f0ed014" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>library</name></member>
      <member refid="classpsl_1_1meta_1_1library_1adafdc22f21e42c36b5214c4eb1133875" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>library</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a667f5b9b1544433ad7a8a94403d6afa3" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>load</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a7fb7f9f6a0580c0f2abde29aef3c7369" prot="private" virt="non-virtual"><scope>psl::meta::library</scope><name>m_Environment</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a20c190043278a642b7110642166ca3dd" prot="private" virt="non-virtual"><scope>psl::meta::library</scope><name>m_LibraryFile</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a1cdcf1895905ae1724dcb2058f51f8f8" prot="private" virt="non-virtual"><scope>psl::meta::library</scope><name>m_LibraryFolder</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a110600d02f8d22888763bf1410d04f05" prot="private" virt="non-virtual"><scope>psl::meta::library</scope><name>m_LibraryLocation</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a86e65f23a609f2aa206785652c42e0fc" prot="private" virt="non-virtual"><scope>psl::meta::library</scope><name>m_MetaData</name></member>
      <member refid="classpsl_1_1meta_1_1library_1acc93dcae6c6b686c528ba66f568a19fb" prot="private" virt="non-virtual"><scope>psl::meta::library</scope><name>m_TagMap</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a84294ded9abf834136f67694f9c87e21" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>operator=</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a315c8ceb312484a903200c5808fefd95" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>operator=</name></member>
      <member refid="classpsl_1_1meta_1_1library_1ae878be8f2dd25e41318582aae5d5a114" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>referencedBy</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a05b36ad8b5bf7df6357c6cf5fd9df00b" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>referencing</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a3929be0a3af743fa0169f6602304b168" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>remove</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a543ced6f44b1e7286546f6510bb38ce6" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>replace_content</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a5b7ea7cdb8261d1b5616db6e3bf99690" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>serialize</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a3f6cfb7e8b3b4e927be163fbcdd68473" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>set</name></member>
      <member refid="classpsl_1_1meta_1_1library_1aee7c93cb86c477d300d3f9adc9ef9f3d" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>set</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a2b1243cd199b4accef5215d898dc305c" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>size</name></member>
      <member refid="classpsl_1_1meta_1_1library_1aa6f273697ac74887e1b30624c3397c6a" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>tags</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a27e240bd3b3cb65018db5ec58f7178f4" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>unload</name></member>
      <member refid="classpsl_1_1meta_1_1library_1a963ec33316190d5567f23ae55768e35b" prot="public" virt="non-virtual"><scope>psl::meta::library</scope><name>~library</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
